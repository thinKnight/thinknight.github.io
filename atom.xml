<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matrix Wall</title>
  <subtitle>I will survive.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thinknight.github.io/"/>
  <updated>2017-07-02T11:22:35.000Z</updated>
  <id>http://thinknight.github.io/</id>
  
  <author>
    <name>thinKnight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim使用笔记</title>
    <link href="http://thinknight.github.io/2015/Tool/vim/"/>
    <id>http://thinknight.github.io/2015/Tool/vim/</id>
    <published>2015-05-24T10:39:41.000Z</published>
    <updated>2017-07-02T11:22:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的<code>Vim</code>常用命令<br><a id="more"></a></p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>hjkl</code> → <code>（←↓↑→）</code>  </li>
</ul>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><ul>
<li><code>i</code> → 插入模式  </li>
<li><code>a</code> → 在光标后插入  </li>
<li><code>r</code> → 替换当前字符  </li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li><code>x</code> → 删除光标下的字符  </li>
<li><code>dd</code> → 删除（并复制）当前行  </li>
<li><code>ndd</code> → 删除接下来 n 行  </li>
</ul>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><ul>
<li><code>yy</code> → 复制当前行  </li>
<li><code>nyy</code> → 复制接下来 n 行  </li>
<li><code>p</code> → 粘贴  </li>
</ul>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ul>
<li><code>Ctrl-r</code> → 重做  </li>
<li><code>u</code> → 撤销  </li>
<li><code>.</code> → （小数点）重复上一次命令  </li>
<li><code>Ctrl-p</code> → 自动提示（或 <code>Ctrl-n</code> ）  </li>
<li><code>/pattern</code> → 搜索 pattern 的字符串  </li>
<li><code>%</code> → 匹配括号移动，包括 <code>[</code>, <code>(</code>, <code>{</code>.  </li>
<li><code>*(resp. #)</code> → 移动到下一个（resp. 上一个）当前光标下匹配的单词  </li>
</ul>
<hr>
<h1 id="行间操作"><a href="#行间操作" class="headerlink" title="行间操作"></a>行间操作</h1><h2 id="跨行操作"><a href="#跨行操作" class="headerlink" title="跨行操作"></a>跨行操作</h2><ul>
<li><code>o</code> → 小写字母o，在当前行之后插入一行，并进入输入模式  </li>
<li><code>O</code> → 大写字母O，在当前行之前插入一行，并进入输入模式  </li>
<li><code>gg</code> → 到第一行  </li>
<li><code>G</code> → 到最后一行  </li>
<li><code>NG</code> → 到第N行（等同于 <code>:N</code> ，但是要按回车所以还是<code>NG</code>快点~）  </li>
</ul>
<h2 id="当前行上移动光标"><a href="#当前行上移动光标" class="headerlink" title="当前行上移动光标"></a>当前行上移动光标</h2><ul>
<li><code>0</code> → 数字0，到行头  </li>
<li><code>g_</code> → 到行尾  </li>
<li><code>^</code> → 到本行第一个不是 blank 字符的位置  </li>
<li><code>$</code> → 到本行最后一个不是 blank 字符的位置  </li>
<li><code>fa</code> → 到下一个为字母 a 的匹配项处， ,（resp. ;） 会移动到下一个（resp. 上一个）  </li>
<li><code>t,</code> → 到字符 , 之前  </li>
<li><code>dt&quot;</code> → 删除”之前的所有内容  </li>
</ul>
<hr>
<h1 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h1><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ol>
<li><code>^</code> → 到行头  </li>
<li><code>Ctrl-v</code> → 开始块操作  </li>
<li><code>j</code> → 向下移动  </li>
<li><code>I-- [ESC]</code> →  <code>I</code>是插入，插入<code>--</code>（或者 <code>//</code>,<code>#</code> 等注释符），按<code>ESC</code>键来为每一行生效  </li>
</ol>
<hr>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul>
<li><code>:wq</code> → 保存并退出  </li>
<li><code>:e &lt;path/to/file&gt;</code>→ 打开  </li>
<li><code>:E</code> → 浏览目录  </li>
<li><code>:w</code> → 保存  </li>
<li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code>  </li>
<li><code>:q!</code> → 强制退出不保存  </li>
</ul>
<hr>
<h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><h2 id="分屏启动"><a href="#分屏启动" class="headerlink" title="分屏启动"></a>分屏启动</h2><ol>
<li>使用大写的<code>O</code>参数来垂直分屏。  </li>
</ol>
<p><code>vim -On file1 file2 ...</code>  </p>
<ol>
<li>使用小写的<code>o</code>参数来水平分屏。  </li>
</ol>
<p><code>vim -on file1 file2 ...</code>  </p>
<h2 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h2><ol>
<li><code>Ctrl-w q</code> → 关闭当前窗口，如果只剩最后一个则退出<code>Vim</code>  </li>
<li><code>Ctrl-w c</code> → 关闭当前窗口  </li>
</ol>
<h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><ol>
<li>上下分割当前打开的文件。  </li>
</ol>
<p><code>Ctrl+W s</code>  </p>
<ol>
<li>上下分割，并打开一个新的文件。  </li>
</ol>
<p><code>:sp filename</code>  </p>
<ol>
<li>左右分割当前打开的文件。  </li>
</ol>
<p><code>Ctrl+W v</code>  </p>
<ol>
<li>左右分割，并打开一个新的文件。  </li>
</ol>
<p><code>:vsp filename</code>  </p>
<h2 id="移动光标-1"><a href="#移动光标-1" class="headerlink" title="移动光标"></a>移动光标</h2><p><code>Ctrl-w 后hjkl</code>  </p>
<hr>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><ul>
<li>之前断断续续用过一段时间 Vim，但都因为工作量不算太多，而且一直在 Windows 下所以就改用了 Sublime Text, 但是最近才把 Vim 重新捡起来才发现真的好用，并且也吧 ST 开启了 Vim 模式，很是方便。  </li>
<li>但 Emacs 什么的就算了吧。  </li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p><a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">点我</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的&lt;code&gt;Vim&lt;/code&gt;常用命令&lt;br&gt;
    
    </summary>
    
    
      <category term="tips" scheme="http://thinknight.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫（二）</title>
    <link href="http://thinknight.github.io/2014/Python/python-crawler-2/"/>
    <id>http://thinknight.github.io/2014/Python/python-crawler-2/</id>
    <published>2014-10-23T10:51:36.000Z</published>
    <updated>2017-07-02T11:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写到了<strong>遍历网站的全部页面</strong>和<strong>向百度提交搜索</strong>，但是其中还存在着许多的问题。<br><a id="more"></a></p>
<h2 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h2><p>在上次的方法中，由于以前都是用简单的正则表达式来解析HTML，所以为了尝鲜我就使用了BeautifulSoup和SGMLParser两种方法。但是经过使用下来发现还是BeautifulSoup好那么一点，而且官方的<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#" target="_blank" rel="external">文档</a>也很详实，以后用起来也会更加方便。  </p>
<p>当然了，这两者在解析的过程中都有自己的局限性，所以还得配合正则表达式使用。  </p>
<h2 id="循环与递归"><a href="#循环与递归" class="headerlink" title="循环与递归"></a>循环与递归</h2><p>由于上次处理的只是遍历一个页面的URL，所以总的来说工作量比较小，然后我就用了<strong>递归</strong>这种最笨的方法。  </p>
<p>但是显而易见，递归是一个非常耗内存的差方法，用递归写过输出斐波那契数列的人都知道，从第十几个数字后就开始慢的不行了，而且最近还听说某厂面试一个应届生的时候因为他用递归处理斐波那契就直接拒了他……所以还是不用的好。  </p>
<p>由于Python中自带队列数据结构，所以通过队列实现迭代循环是目前较为理想的方案。  </p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>在爬虫程序中，当我提交了请求之后CPU需要等待网站相应后才能进一步计算，也就是需要等待<code>urllib2.urlopen()</code>得到相应之后才能read网页的内容，所以这就需要等待一段时间，所以为了提高爬虫的效率，就需要开启多线程进程抓取。</p>
<h2 id="健壮"><a href="#健壮" class="headerlink" title="健壮"></a>健壮</h2><p>在爬虫运行的时候，如果因为被网站的防爬虫机制禁止了爬取行为，那就会导致整个爬虫程序的意外退出，所以就必须把<code>urllib2</code>的行为包起来。  </p>
<p>另外，如果同一个IP在短时间内对一个网站进行大量访问，可能会被网站的防爬虫措施制裁，比如豆瓣…所以为了避免爬虫挂掉，就得设置一个时间间隔，也就是让线程暂时阻塞，等时间到了之后再加入线程队列中。  </p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>在上次的遍历一个URL中的所有URL任务中，虽然一次能抓取到几千个URL，但是并不能保证这些URL都是不重复的，如果在这些URL中有环路的话，爬虫就会先入死循环中，所以对抓取到的URL进行去重就是一个要面临的问题。  </p>
<p>当需要处理的数据很少的时候，可以用<code>set</code>集合来解决，但是当数据量变大的时候，就得靠<strong>Bloom Filter</strong>（布隆过滤器）了。BF的算法不算非常复杂，不过好歹有现成的<a href="https://github.com/jaybaird/python-bloomfilter/blob/master/pybloom/pybloom.py" target="_blank" rel="external">轮子</a>，用起来也方便了许多。  </p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pybloom <span class="keyword">import</span> BloomFilter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = BloomFilter(capacity=<span class="number">10000</span>, error_rate=<span class="number">0.001</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range_fn(<span class="number">0</span>, f.capacity):</div><div class="line"><span class="meta">... </span>_ = f.add(i)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">in</span> f</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.capacity <span class="keyword">in</span> f</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(f) &lt;= f.capacity</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1.0</span> - (len(f) / float(f.capacity))) &lt;= f.error_rate + <span class="number">2e-18</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pybloom <span class="keyword">import</span> ScalableBloomFilter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sbf = ScalableBloomFilter(mode=ScalableBloomFilter.SMALL_SET_GROWTH)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>count = <span class="number">10000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range_fn(<span class="number">0</span>, count):</div><div class="line"><span class="meta">... </span>_ = sbf.add(i)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sbf.capacity &gt; count</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(sbf) &lt;= count</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1.0</span> - (len(sbf) / float(count))) &lt;= sbf.error_rate + <span class="number">2e-18</span></div><div class="line"><span class="keyword">True</span></div><div class="line">```  </div><div class="line"></div><div class="line">------------</div><div class="line"></div><div class="line"><span class="comment"># 新任务</span></div><div class="line">&gt;自动向百度提交搜索请求，搜索nuist.edu.cn中包含？的URL，从返回的结果页面中，提取每一个分页中的URL，并将结果写入一个文件中。**这次强调所有结果有多少页就爬取多少页**！</div><div class="line"></div><div class="line"><span class="comment">## 实现</span></div><div class="line">```Python</div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> threading </div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">from</span> pybloom <span class="keyword">import</span> BloomFilter</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># use Bloom Filter</span></div><div class="line">bf = BloomFilter(<span class="number">1000000</span>, <span class="number">0.01</span>)</div><div class="line"></div><div class="line"><span class="comment"># translate the default code</span></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line"><span class="comment"># define a queue</span></div><div class="line">url_wait = Queue.Queue(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, num)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.url = url</div><div class="line">        <span class="comment"># self.tnum = num</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># traverse the whole url</span></div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line">        traverse(self.url)</div><div class="line">        <span class="comment"># print "This is thread-%d" % self.tnum</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_nextpage</span><span class="params">(new_url)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        tmp = urllib2.urlopen(new_url)</div><div class="line">        content = tmp.read()</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    soup = BeautifulSoup(content)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(href=re.compile(<span class="string">"rsv_page=1"</span>)):</div><div class="line">        tmp_link = link.get(<span class="string">'href'</span>)</div><div class="line">        real_url = <span class="string">"http://www.baidu.com"</span> + tmp_link</div><div class="line">        <span class="keyword">return</span> real_url  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(url)</span>:</span></div><div class="line">    </div><div class="line">    fp = open(<span class="string">"all_url.txt"</span>, <span class="string">"a"</span>)</div><div class="line"></div><div class="line">    url_wait.put(url)</div><div class="line">     </div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> url_wait.empty():</div><div class="line">        url = url_wait.get()</div><div class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> bf:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                content = urllib2.urlopen(url).read() </div><div class="line">                soup = BeautifulSoup(content)                                     </div><div class="line">                <span class="keyword">for</span> urls <span class="keyword">in</span> soup.find_all(href=re.compile(<span class="string">"http"</span>)):                     </div><div class="line">                    link = urls.get(<span class="string">'href'</span>)</div><div class="line">                    url_wait.put(link)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">pass</span></div><div class="line"></div><div class="line">            bf.add(url)</div><div class="line">            fp.write( url + <span class="string">'\n\n'</span>)   </div><div class="line"></div><div class="line">    fp.close()  </div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    num = <span class="number">0</span></div><div class="line">    fp = open(<span class="string">"target.txt"</span>, <span class="string">"a"</span>)</div><div class="line">    url_pool = Queue.Queue(<span class="number">0</span>)</div><div class="line">    start_url = <span class="string">"http://www.baidu.com/s?wd=site:(nuist.edu.cn)%20?"</span></div><div class="line">    </div><div class="line">    url_pool.put(start_url)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> url_pool.empty():</div><div class="line">            new_url = url_pool.get()</div><div class="line">            fp.write(new_url + <span class="string">"\n\n"</span>)</div><div class="line"></div><div class="line">            nextpage = find_nextpage(new_url)</div><div class="line">            url_pool.put(nextpage)</div><div class="line">        </div><div class="line">            Thread = MyThread(new_url, num)</div><div class="line">            num += <span class="number">1</span></div><div class="line">            Thread.start()</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    fp.close()  </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </div><div class="line">    main()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写到了&lt;strong&gt;遍历网站的全部页面&lt;/strong&gt;和&lt;strong&gt;向百度提交搜索&lt;/strong&gt;，但是其中还存在着许多的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://thinknight.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器</title>
    <link href="http://thinknight.github.io/2014/Compiler/Lexical-analyzer/"/>
    <id>http://thinknight.github.io/2014/Compiler/Lexical-analyzer/</id>
    <published>2014-10-19T11:30:27.000Z</published>
    <updated>2017-07-02T11:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个词法分析器的demo。<br><a id="more"></a></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> i, j;</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">int</span> count;</div><div class="line"><span class="keyword">int</span> start_p;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">analyse</span><span class="params">(<span class="keyword">char</span> *tmp, <span class="keyword">int</span> start_p, FILE *fp_w)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>( <span class="built_in">isspace</span>(tmp[start_p]) )</div><div class="line">        start_p++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( <span class="built_in">isalpha</span>(tmp[start_p]) )</div><div class="line">    &#123;</div><div class="line">        count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">char</span> tmp_str[<span class="number">1000</span>] = &#123;&#125;;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>( <span class="built_in">isalpha</span>(tmp[start_p]) )</div><div class="line">        &#123;</div><div class="line">            tmp_str[count] = tmp[start_p]; </div><div class="line">            count++;</div><div class="line">            start_p++;</div><div class="line">        &#125;</div><div class="line">        start_p--;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( is_keyword(tmp_str, fp_w) )&#123;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;0, %s&gt;\n"</span>, tmp_str);</div><div class="line">            <span class="built_in">fprintf</span>(fp_w, <span class="string">"&lt;0, %s&gt;\n"</span>, tmp_str);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( <span class="built_in">isdigit</span>(tmp[start_p]) )</div><div class="line">        &#123;</div><div class="line">            count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">char</span> tmp_str[<span class="number">1000</span>] = &#123;&#125;;</div><div class="line"></div><div class="line">            <span class="keyword">while</span>( <span class="built_in">isdigit</span>(tmp[start_p]) )</div><div class="line">            &#123;</div><div class="line">                tmp_str[count] = tmp[start_p]; </div><div class="line">                count++;</div><div class="line">                start_p++;</div><div class="line">            &#125;</div><div class="line">            start_p--;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;1, %s&gt;\n"</span>, tmp_str);</div><div class="line">            <span class="built_in">fprintf</span>(fp_w, <span class="string">"&lt;1, %s&gt;\n"</span>, tmp_str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>( !<span class="built_in">isalpha</span>(tmp[start_p]) &amp;&amp; !<span class="built_in">isdigit</span>(tmp[start_p]) )</div><div class="line">            &#123;</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">char</span> tmp_str[<span class="number">1000</span>] = &#123;&#125;;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>( !<span class="built_in">isalpha</span>(tmp[start_p+<span class="number">1</span>]) &amp;&amp; !<span class="built_in">isdigit</span>(tmp[start_p+<span class="number">1</span>]) )</div><div class="line">                &#123;</div><div class="line">                    tmp_str[count] = tmp[start_p];</div><div class="line">                    count++;	start_p++;</div><div class="line">                    tmp_str[count] = tmp[start_p];</div><div class="line">                    <span class="keyword">if</span>( is_symbol(tmp_str, fp_w) )&#123;</div><div class="line">                        ;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        count--;    start_p--;</div><div class="line">                        tmp_str[<span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">                        tmp_str[count] = tmp[start_p];</div><div class="line">                        is_symbol(tmp_str, fp_w);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    tmp_str[count] = tmp[start_p]; </div><div class="line">                    is_symbol(tmp_str, fp_w);</div><div class="line">                &#125;	</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    len = <span class="built_in">strlen</span>(tmp);</div><div class="line">    <span class="keyword">if</span>( start_p == len )</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        analyse(tmp, start_p+<span class="number">1</span>, fp_w);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_keyword</span><span class="params">(<span class="keyword">char</span> *tmp, FILE *fp_w)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *keyword[] = &#123;</div><div class="line">        <span class="string">"main"</span>,   <span class="string">"void"</span>,    <span class="string">"int"</span>,    <span class="string">"float"</span>,  <span class="string">"char"</span>,     <span class="string">"double"</span>,   <span class="string">"for"</span>, </div><div class="line">        <span class="string">"if"</span>,     <span class="string">"else"</span>,    <span class="string">"while"</span>,  <span class="string">"do"</span>,     <span class="string">"break"</span>,    <span class="string">"switch"</span>,   <span class="string">"case"</span>,</div><div class="line">        <span class="string">"struct"</span>, <span class="string">"typedef"</span>, <span class="string">"char"</span>,   <span class="string">"return"</span>, <span class="string">"continue"</span>, <span class="string">"sizeof"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//total number:20</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>( tmp, keyword[i]) == <span class="number">0</span> )</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;%d, %s&gt;\n"</span>, i+<span class="number">2</span>, tmp);</div><div class="line">            <span class="built_in">fprintf</span>(fp_w, <span class="string">"&lt;%d, %s&gt;\n"</span>, i+<span class="number">2</span>, tmp);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_symbol</span><span class="params">(<span class="keyword">char</span> *tmp, FILE *fp_w)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *symbol[] = &#123;</div><div class="line"></div><div class="line">        <span class="string">"+"</span>,  <span class="string">"-"</span>,  <span class="string">"*"</span>,  <span class="string">"/"</span>,  <span class="string">"&lt;"</span>,  <span class="string">"&gt;"</span>,  <span class="string">"="</span>,  <span class="string">"!"</span>,  <span class="string">"&amp;"</span>,  <span class="string">"|"</span>, </div><div class="line">        <span class="string">"\\"</span>, <span class="string">"#"</span>,  <span class="string">"\""</span>, <span class="string">"%"</span>,  <span class="string">"^"</span>,</div><div class="line"></div><div class="line">        <span class="string">"++"</span>, <span class="string">"+="</span>, <span class="string">"--"</span>, <span class="string">"-="</span>, <span class="string">"*="</span>, <span class="string">"/="</span>, <span class="string">"%="</span>, <span class="string">"&amp;="</span>, <span class="string">"^="</span>, <span class="string">"|="</span>, </div><div class="line">        <span class="string">"&lt;="</span>, <span class="string">"&gt;="</span>, <span class="string">"=="</span>, <span class="string">"!="</span>, <span class="string">"&amp;&amp;"</span>, <span class="string">"||"</span>, <span class="string">"&gt;&gt;"</span>, <span class="string">"&lt;&lt;"</span>, <span class="string">"?:"</span>, <span class="string">"-&gt;"</span>,</div><div class="line"></div><div class="line">        <span class="string">"&#123;"</span>,  <span class="string">"&#125;"</span>,  <span class="string">"("</span>,  <span class="string">")"</span>,  <span class="string">"["</span>,  <span class="string">"]"</span>,  <span class="string">","</span>,  <span class="string">";"</span>,  <span class="string">":"</span>,  <span class="string">"."</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//total number:45</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">45</span>; ++i)</div><div class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>( tmp, symbol[i]) == <span class="number">0</span> )</div><div class="line">        <span class="comment">// printf("Yes! No.%d: %s\n", i, tmp);</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;%d, %s&gt;\n"</span>, <span class="number">22</span> + i, tmp);</div><div class="line">            <span class="built_in">fprintf</span>(fp_w, <span class="string">"&lt;%d, %s&gt;\n"</span>, <span class="number">22</span> + i, tmp);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_blankline</span><span class="params">(<span class="keyword">char</span> *tmp)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(tmp);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( !<span class="built_in">isspace</span>(tmp[i]) )</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;	</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_comments</span><span class="params">(<span class="keyword">char</span> *tmp)</span></span></div><div class="line">&#123;</div><div class="line">    len = <span class="built_in">strlen</span>(tmp);</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tmp[i] == <span class="string">'/'</span> &amp;&amp; tmp[i+<span class="number">1</span>] == <span class="string">'/'</span>)</div><div class="line">        &#123;</div><div class="line">			</div><div class="line">            tmp[i] = <span class="string">'\0'</span>;</div><div class="line">			</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> tmp[<span class="number">100</span>] = <span class="string">""</span>;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">""</span>;</div><div class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">    FILE *fp, *fp_tmp;</div><div class="line">    fp = fopen(<span class="string">"test.c"</span>, <span class="string">"r"</span>);</div><div class="line">    fp_tmp = fopen(<span class="string">"tmp.c"</span>, <span class="string">"w"</span>);</div><div class="line">    <span class="keyword">while</span>(fgets(str, <span class="number">100</span>, fp) != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'/'</span> &amp;&amp; str[i+<span class="number">1</span>] == <span class="string">'/'</span>)</div><div class="line">            &#123;</div><div class="line">                str[i] = <span class="string">'\n'</span>;</div><div class="line">                str[i+<span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'/'</span> &amp;&amp; str[i+<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">            &#123;</div><div class="line">                str[i] = <span class="string">'\0'</span>;</div><div class="line">                flag = <span class="number">1</span>;</div><div class="line">                <span class="built_in">fputs</span>(str, fp_tmp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'*'</span> &amp;&amp; str[i+<span class="number">1</span>] == <span class="string">'/'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j)</div><div class="line">                &#123;</div><div class="line">                    str[j] = str[j+i+<span class="number">2</span>];</div><div class="line">                &#125;</div><div class="line">                str[j] = <span class="string">'\0'</span>;</div><div class="line">                flag = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( flag == <span class="number">0</span> )</div><div class="line">            <span class="built_in">fputs</span>(str, fp_tmp);</div><div class="line">    &#125;</div><div class="line">    fcloseall();</div><div class="line"></div><div class="line">    FILE *fp_new;</div><div class="line">    FILE *fp_w;</div><div class="line">    fp_new = fopen(<span class="string">"tmp.c"</span>, <span class="string">"r"</span>);</div><div class="line">    fp_w   = fopen(<span class="string">"Lex_Result.txt"</span>, <span class="string">"w"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!feof(fp_new))&#123;</div><div class="line">        <span class="keyword">if</span>(fgets(tmp, <span class="number">100</span>, fp_new))</div><div class="line">            <span class="keyword">if</span>( is_blankline(tmp) == <span class="number">0</span>)</div><div class="line">                analyse(tmp, <span class="number">0</span>, fp_w);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fcloseall();</div><div class="line">    remove(<span class="string">"tmp.c"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h2><pre><code class="C"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; //This is a simple target code</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"TEST BEGUN!"</span>);
    <span class="keyword">int</span> a = <span class="number">0</span>;
    <span class="keyword">int</span> b = <span class="number">1</span>;
    <span class="comment">/*
        You can not see me!
    */</span>
    <span class="keyword">if</span>(a &lt;= b)
        <span class="built_in">printf</span>(<span class="string">"Yes"</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
    <span class="comment">//That's it!</span>
}
</code></pre>
<h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><pre><code class="C">&lt;33, #&gt;
&lt;0, include&gt;
&lt;26, &lt;&gt;
&lt;0, stdio&gt;
&lt;66, .&gt;
&lt;0, h&gt;
&lt;27, &gt;&gt;
&lt;4, int&gt;
&lt;2, main&gt;
&lt;59, (&gt;
&lt;60, )&gt;
&lt;57, {&gt;
&lt;0, printf&gt;
&lt;59, (&gt;
&lt;34, "&gt;
&lt;0, TEST&gt;
&lt;0, BEGUN&gt;
&lt;29, !&gt;
&lt;34, "&gt;
&lt;60, )&gt;
&lt;64, ;&gt;
&lt;4, int&gt;
&lt;0, a&gt;
&lt;28, =&gt;
&lt;1, 0&gt;
&lt;64, ;&gt;
&lt;4, int&gt;
&lt;0, b&gt;
&lt;28, =&gt;
&lt;1, 1&gt;
&lt;64, ;&gt;
&lt;9, if&gt;
&lt;59, (&gt;
&lt;0, a&gt;
&lt;47, &lt;=&gt;
&lt;0, b&gt;
&lt;60, )&gt;
&lt;0, printf&gt;
&lt;59, (&gt;
&lt;34, "&gt;
&lt;0, Yes&gt;
&lt;34, "&gt;
&lt;60, )&gt;
&lt;64, ;&gt;
&lt;19, return&gt;
&lt;1, 0&gt;
&lt;64, ;&gt;
&lt;58, }&gt;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个词法分析器的demo。&lt;br&gt;
    
    </summary>
    
    
      <category term="Compile" scheme="http://thinknight.github.io/tags/Compile/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫（一）</title>
    <link href="http://thinknight.github.io/2014/Python/python-crawler-1/"/>
    <id>http://thinknight.github.io/2014/Python/python-crawler-1/</id>
    <published>2014-10-13T13:48:33.000Z</published>
    <updated>2017-07-02T11:21:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>从零开始写爬虫<br><a id="more"></a></p>
<h2 id="一、遍历网站的全部页面"><a href="#一、遍历网站的全部页面" class="headerlink" title="一、遍历网站的全部页面"></a>一、遍历网站的全部页面</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要遍历一个网站的全部页面,要做的就是先打开目标网站的源码,从中提取所有的URL,然后再逐个遍历,并保存已处理过的URL。  </p>
<h4 id="1-提取URL"><a href="#1-提取URL" class="headerlink" title="1.提取URL"></a>1.提取URL</h4><p>从一堆HTML中提取可用的URL是一件轻松的事,处理的方法也有很多。  </p>
<ul>
<li>正则表达式提取  </li>
<li>BeautifulSoup提取</li>
<li>自带库sgmlib中的SGMLParser类  </li>
</ul>
<p>这里就试试第三种方法。  </p>
<h4 id="2-存储URL"><a href="#2-存储URL" class="headerlink" title="2.存储URL"></a>2.存储URL</h4><p>提取出URL后,分开存储刚刚提取出来的URL和已经处理过的URL就是接下来要解决的问题。  </p>
<p>一开始想过存在列表里面,但是从中提取和pop出URL的顺序又成了问题,所以这里采用Python自带的<strong>队列</strong>数据结构。  </p>
<p>然后处理完的URL就直接存入文件,并且计数,即为已经访问到的页面数量。  </p>
<h4 id="3-实现函数"><a href="#3-实现函数" class="headerlink" title="3.实现函数"></a>3.实现函数</h4><p>接下来的任务就是运行函数来处理URL了,但是我现在用的只是最笨的<strong>递归</strong>,效率低下不说,对内存也是一个很大的考验。所以之后会通过多线程编程来解决这个问题,把URL放入内存池中,规定每次允许运行的线程数,这样就能在一定程度上提升效率和速度了。  </p>
<h4 id="4-具体代码"><a href="#4-具体代码" class="headerlink" title="4.具体代码"></a>4.具体代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 搜寻现成的爬虫代码，弄明白怎样遍历一个网站的全部页面，编码实现：</span></div><div class="line"><span class="comment"># 能够遍历一个网站的大部分页面，保存输出可遍历页面的URL，并统计访问到的页面数量。</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">from</span> sgmllib <span class="keyword">import</span> SGMLParser</div><div class="line"></div><div class="line">url_queue = Queue.Queue(<span class="number">0</span>)</div><div class="line">url_num = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">find_url</span><span class="params">(SGMLParser)</span>:</span></div><div class="line">	<span class="string">"""docstring for find_url</span></div><div class="line">		store the urls into url_new</div><div class="line"></div><div class="line">	"""</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		SGMLParser.__init__(self)</div><div class="line">		self.url_new = []</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">start_a</span><span class="params">(self, attrs)</span>:</span></div><div class="line">		href = [v <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs <span class="keyword">if</span> k==<span class="string">'href'</span>] </div><div class="line">		</div><div class="line">		<span class="keyword">if</span> re.match(<span class="string">r'^https?:/&#123;2&#125;\w.+$'</span>, <span class="string">""</span>.join(href)):</div><div class="line">			self.url_new.extend(href)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">()</span>:</span></div><div class="line">	url = url + <span class="number">1</span></div><div class="line"></div><div class="line">	url_given = url_queue.get()</div><div class="line"></div><div class="line">	url_traversed.write(url_given + <span class="string">"\n"</span>) </div><div class="line"></div><div class="line">	content = urllib2.urlopen(url_given).read()	</div><div class="line">	result  = find_url()</div><div class="line">	result.feed(content) </div><div class="line">	<span class="keyword">for</span> urls <span class="keyword">in</span> result.url_new:</div><div class="line">		<span class="comment"># print i                 </span></div><div class="line">		url_queue.put(urls)</div><div class="line"></div><div class="line">	<span class="keyword">while</span> <span class="keyword">not</span> url_queue.empty():</div><div class="line">		open_url()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">	url = <span class="string">"http://movie.douban.com"</span></div><div class="line"></div><div class="line">	url_traversed = open(<span class="string">'URLSTORE.txt'</span>, <span class="string">'w'</span>)</div><div class="line"></div><div class="line">	url_queue.put(url)</div><div class="line"></div><div class="line">	open_url()</div><div class="line"></div><div class="line">	url_traversed.closed()</div><div class="line"></div><div class="line">	<span class="keyword">print</span> <span class="string">"The number of the traversed URL is %d"</span> % url_num</div><div class="line">```  </div><div class="line"></div><div class="line"><span class="comment">## 二、向百度提交搜索</span></div><div class="line"><span class="comment">#### 1.提交搜索</span></div><div class="line">我现在还是用的最笨的方法,即直接打开包含需要搜索内容的URL,就能得到搜索页面的源码。  </div><div class="line"></div><div class="line">用POST和GET提交的方法下次再用。  </div><div class="line"></div><div class="line"><span class="comment">#### 2.处理结果  </span></div><div class="line">用BeautifulSoup查找&lt;div&gt;标签间的内容,但是这个还是只能大概地过滤,并不能很精准地返回搜索内容。  </div><div class="line"></div><div class="line"><span class="comment">#### 3.待解问题</span></div><div class="line"><span class="number">1.</span> 用POST和GET方法提交搜索。  </div><div class="line"><span class="number">2.</span> 细致地处理返回的搜索结果。  </div><div class="line"><span class="number">3.</span> 遍历所有的搜索结果。  </div><div class="line"></div><div class="line">```Python</div><div class="line"><span class="comment"># -*-coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 2.用百度设置内的高级搜索功能，在指定网站中搜索URL中包含？的结果。编程实现：</span></div><div class="line"><span class="comment"># 	自动向百度提交搜索，在指在指定网站中搜索URL中包含？的结果，提取百度搜索结果并输出到文件。</span></div><div class="line"><span class="comment">#   例如，搜索nuist.edu.cn，其实就是想百度提交搜索字符串site:(nuist.edu.cn) ?</span></div><div class="line"></div><div class="line"><span class="comment"># http://www.baidu.com/s?wd=</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line">reload(sys)   </div><div class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_baidu</span><span class="params">()</span>:</span></div><div class="line">    url = urllib2.urlopen(<span class="string">"http://www.baidu.com/s?wd=site:(nuist.edu.cn)%20?"</span>)</div><div class="line"></div><div class="line">  </div><div class="line">    urltmp = url.read()</div><div class="line"></div><div class="line">    <span class="comment"># urltmp = urltmp.decode("UTF-8").encode("UTF-8")</span></div><div class="line"></div><div class="line">    soup = BeautifulSoup(urltmp)</div><div class="line"></div><div class="line">    res = soup.find(name=<span class="string">'div'</span>).getText(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">    ss = open(<span class="string">'ss.txt'</span>, <span class="string">'w'</span>)</div><div class="line">    ss.write(res)</div><div class="line">    ss.close()</div><div class="line"></div><div class="line">search_baidu()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从零开始写爬虫&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://thinknight.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关于进程的问题</title>
    <link href="http://thinknight.github.io/2014/OS/process-qa/"/>
    <id>http://thinknight.github.io/2014/OS/process-qa/</id>
    <published>2014-10-10T10:04:58.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>哲学家就餐问题等<br><a id="more"></a></p>
<h1 id="一、经典的IPC问题"><a href="#一、经典的IPC问题" class="headerlink" title="一、经典的IPC问题"></a>一、经典的IPC问题</h1><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>5个哲学家围绕一张圆桌而坐，每个哲学家面前都有一盘通心粉，由于通心粉很滑，所以需要两把叉子才能夹住。相邻两个盘子之间有一把叉子。哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两把叉子,思考时则同时将两把叉子放回原处。  </p>
<p><img src="/img/philo-dinner.png" alt="dinner"></p>
<p>如何保证哲学家们的动作有序进行?如:  </p>
<ul>
<li>不出现相邻者同时要求进餐;</li>
<li>不出现有人永远拿不到叉子。</li>
</ul>
<p>为了避免死锁，和只能让一个哲学家进餐的状态，我们可以使用下面的方法。  </p>
<hr>
<p>使用一个数组state跟踪每一个哲学家是在进餐，思考还是饥饿状态（正在试图拿叉子），一个哲学家只有在两个邻居都没有进餐时才允许进入进餐状态。  </p>
<p>第i个哲学家由宏LEFT和RIGHT定义。比如i为2，则LEFT为1，RIGHT为3。  </p>
<pre><code class="C"><span class="meta">#<span class="meta-keyword">define</span> N           5                   <span class="comment">/*哲学家数目*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> LEFT        (i + N - 1) % N     <span class="comment">/*i的左邻居编号*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> RIGHT       (i + 1) % N         <span class="comment">/*i的右邻居编号*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> THINKING    0                   <span class="comment">/*哲学家在思考*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> HUNGRY      1                   <span class="comment">/*哲学家试图拿起叉子*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> EATING      2                   <span class="comment">/*哲学家进餐*/</span></span>
<span class="keyword">typedef</span> <span class="keyword">int</span> seamphore;                  <span class="comment">/*信号量是一种特殊的整型数据*/</span>
<span class="keyword">int</span> state[N];                           <span class="comment">/*数组用来跟踪记录每位哲学家的状态*/</span>
seamphore mutex = <span class="number">1</span>;                    <span class="comment">/*临界区的互斥*/</span>
seamphore s[N];                         <span class="comment">/*每个哲学家一个信号量*/</span>

<span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span>                 <span class="comment">/*i：哲学家编号，从0到N-1*/</span>
</span>{
    <span class="keyword">while</span>(TRUE){                    <span class="comment">/*无限循环*/</span>
    }
}

<span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span>                  <span class="comment">/*i：哲学家编号，从0到N-1*/</span>
</span>{    
    down(&amp;mutex);                   <span class="comment">/*进入临界区*/</span>
    state[i] = HUNGRY;              <span class="comment">/*记录哲学家i处于饥饿的状态*/</span>
    test(i);                        <span class="comment">/*尝试获取2把叉子*/</span>
    up(&amp;mutex);                     <span class="comment">/*离开临界区*/</span>
    down(&amp;s[i]);                    <span class="comment">/*如果得不到需要的叉子则阻塞*/</span>
}    

<span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(i)</span>                       <span class="comment">/*i：哲学家编号，从0到N-1*/</span>
</span>{
    down(&amp;mutex);                   <span class="comment">/*进入临界区*/</span>
    state[i] = THINKING;            <span class="comment">/*哲学家已就餐完毕*/</span>
    test(LEFT);                     <span class="comment">/*检查左边的邻居现在可以吃吗*/</span>
    test(RIGHT);                    <span class="comment">/*检查右边的邻居现在可以吃吗*/</span>
    up(&amp;mutex);                     <span class="comment">/*离开临界区*/</span>
}

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span>                            <span class="comment">/*i：哲学家编号，从0到N-1*/</span>
</span>{
    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING){
        state[i] = EATING;
        up(&amp;s[i]);
    }
}
</code></pre>
<p>该程序使用了一个信号量数组，每个信号量对应一个哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞。  </p>
<hr>
<h1 id="二、进程与线程书后习题"><a href="#二、进程与线程书后习题" class="headerlink" title="二、进程与线程书后习题"></a>二、进程与线程书后习题</h1><hr>
<p><strong>1.有没有可能发生阻塞到运行，就绪到阻塞的转换？</strong>  </p>
<ol>
<li>从阻塞到运行的状态是可以的，假设某个进程在I/O上阻塞，而且I/O就此结束，如果此时CPU是空闲的话，这个进程就可以从阻塞状态直接转换到运行态。  </li>
<li>而从就绪态转换到阻塞态是不可能的，因为一个就绪的进程是不会做诸如I/O这些会产生阻塞的事，只有运行的进程才能被阻塞。  </li>
</ol>
<hr>
<p><strong>4.内核使用单独堆栈的原因</strong></p>
<ol>
<li>你不会希望由于一些写的不好的用户程序没有被分配到足够多的堆栈空间而导致系统崩溃。  </li>
<li>如果内核把数据保留在用户空间，然后从系统调用返回，那么一个恶意用户就有可能使用这些数据查找关于其他进程的信息。  </li>
</ol>
<hr>
<p><strong>5. 多个程序能够并行运行，比它们顺序执行完成的要快。假设有两个作业同时开始执行，每个需要10分钟的CPU时间。如果顺序执行，那么最后一个作业需要多长时间可以完成？如果并行执行又需要多长时间？假设I/0等待占50%。</strong></p>
<ol>
<li><p>顺序执行的时候，因为I/O频率为50%，CPU时间为10分钟，所以每个作业需要20分钟，则最后一个作业需要40分钟来完成。  </p>
</li>
<li><p>并行执行时，CPU的利用率为1-0.5²，这意味着每分钟每个作业在并行时实际获得用于处理的CPU时间是0.75/2 = 0.375分钟，所以为了执行完需要10分钟的CPU时间的工作，每个作业必须运行10/0.375≈26.67分钟。又因为是并行的，相当于两个作业同时完成，因此是26.67分钟。  </p>
</li>
</ol>
<hr>
<p><strong>7.如果创建一个多线程进程，若子进程得到全部父进程线程的副本，会出现问题。假如原有线程之一正在等待键盘输入，现在则成为两个线程在等待键盘输入，每个进程有一个。在单线程进程中也会发生这种问题吗？</strong><br>不会。如果单线程进程在键盘上阻塞，就不能创建子进程。</p>
<hr>
<p><strong>8.在多线程Web服务器中，如果读取文件的唯一途径是正常的阻塞read系统调用，那么Web服务器应该使用用户级线程还是内核级线程，为什么？</strong><br>用内核级线程。<br>当一个工作线程从磁盘读取一个网页时，它就会被阻塞。如果使用了用户级线程，那这个动作就会阻塞整个进程，那么多线程就没有意义了。所以就应该使用内核级线程，这样在一些线程阻塞时就不会影响其他线程。</p>
<hr>
<p><strong>11.为什么线程要通过调用thread_yield自愿放弃CPU？毕竟，由于没有周期性的时钟中断，线程可以不交回CPU。</strong><br>进程中的线程通常是相互协作而不是相互独立的，如果放弃是对应用程序的有利需要的话，那么线程将放弃CPU。毕竟通常都是一个程序员写所有的代码。</p>
<hr>
<p><strong>12.线程可以被时钟中断抢占吗？如果可以，什么情形下可以？如果不可以，为什么不可以？</strong><br>用户级线程不可以被时钟剥夺，除非整个进程的时间片被用完。内核级的线程可以单独地被剥夺。在后一种情况中，如果一个线程运行太久，那么时钟会终端当前的进程，因此当前的线程也被中断。内核可以自由地从同一个进程中选取其他线程运行。</p>
<hr>
<p><strong>13.对使用单线程文件服务器和多线程服务器读取文件进行比较。假设所需要的数据都在高速缓存中，花费15ms获得工作请求，分派工作，并处理其余必要工。如果在三分之一时间时，需要一个磁盘操作，要另外花费75ms，此时该线程进入睡眠。在单线程情形下服务器每秒可以处理多少个请求？如果是多线程呢？</strong></p>
<ul>
<li>在单线程的情况下，cache命中需要15ms，没命中需要90ms。那加权平均时间为2/3x15 + 1/3x90，因此平均请求时间为40ms，所以服务器一秒可以处理25个请求。</li>
<li>对于一个多线程服务器，所有的磁盘等待都是重叠的，所以每个请求花费15ms，所以服务器可以每秒处理200/3个请求。</li>
</ul>
<hr>
<p><strong>14.在用户空间实现线程，其最大的优点是什么？最大的缺点是什么？</strong></p>
<ul>
<li>用户级线程包可以在不支持线程的操作系统上实现</li>
<li><p>允许每个进程有自己定制的调度算法</p>
</li>
<li><p>如何实现阻塞系统调用</p>
</li>
<li><p>如果一个线程开始运行，那么在该线程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</p>
</li>
<li><p>最大的优点是效率。No traps to the kernel are needed to switch threads.</p>
</li>
<li>最大的缺点是如果一个线程发生阻塞，那整个进程就阻塞了。</li>
</ul>
<hr>
<p><strong>38.运行在CTSS上的一个进程需要30个时间片完成。该进程必须被调入多少次，包括第一次（在该进程运行之前）？</strong><br>第一次得到1个时间片。随后获得2,4,8,15个时间片，因此必须经过5次交换。</p>
<hr>
<p><strong>41.一个软实时系统有4个周期时间，其周期分别为50ms，100ms，200ms和250ms。假设这4个事件分别需要35ms，20ms，10ms和x ms的CPU时间。保持系统可调度的最大x值是多少？</strong><br>所使用的CPU的片断为35/50 + 20/100 + 10/200 + x/250。为了使得进程可调度，必须是总和小于1。因此，x必须小于12.5ms。</p>
<hr>
<p><strong>42.请解释为什么两级调度比较常用？</strong><br>当内存太小不能载入所有就绪进程时，就需要使用两级调度。某些进程被载入内存，并且从中选择一个运行。内存中进程会随着时间调整。这种算法容易实现也非常有效，另外，时间片轮转调度并不管进程是否在内存中。</p>
<hr>
<p><strong>43.一个实时系统需要处理两个语音通信，每个运行5ms，然后每次突发消耗1ms CPU时间，加上25帧/秒的一个视频，每一帧需要20ms的CPU时间。这个系统是可调度的吗？</strong><br>每个语音通信每秒运行200次并且每次突发消耗1ms，所以每个语音通信需要200ms每秒或者两个需要400ms每秒。视频每秒运行25次并且每次消耗20ms，一共是500ms每秒。它们每秒一共消耗900ms，所以有时间剩余，系统可调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哲学家就餐问题等&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://thinknight.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程间调度</title>
    <link href="http://thinknight.github.io/2014/OS/schedule/"/>
    <id>http://thinknight.github.io/2014/OS/schedule/</id>
    <published>2014-10-10T08:48:52.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>当计算机系统是多道程序设计系统时，通常就会有多个进程或者线程同时竞争CPU。只要有两个或者多个进程处于就绪状态，这种情况就会发生。如果此时只有一个CPU可用，那么就必须选择下一个要运行的进程。<br><a id="more"></a></p>
<p>在操作系统中完成选择工作的这一部分称为<strong>调度程序</strong>，该程序使用的算法称为调度算法。</p>
<h2 id="一、何时调度"><a href="#一、何时调度" class="headerlink" title="一、何时调度"></a>一、何时调度</h2><ul>
<li>在创建一个新进程后，需要决定是运行父进程还是运行子进程。  </li>
<li>在一个进程退出时必须做出调度决策。  </li>
<li>当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。  </li>
<li>在一个I/O中断发生时，必须做出调度决策。  </li>
<li>在分时系统中，当一个时钟中断发生时。  </li>
</ul>
<h2 id="二、调度算法"><a href="#二、调度算法" class="headerlink" title="二、调度算法"></a>二、调度算法</h2><h3 id="1-先来先服务FCFS-first-come-first-served"><a href="#1-先来先服务FCFS-first-come-first-served" class="headerlink" title="1.先来先服务FCFS(first-come first-served)"></a>1.先来先服务FCFS(first-come first-served)</h3><h4 id="这是最简单的调度算法-按先后顺序调度。"><a href="#这是最简单的调度算法-按先后顺序调度。" class="headerlink" title="这是最简单的调度算法,按先后顺序调度。"></a>这是最简单的调度算法,按先后顺序调度。</h4><ul>
<li>按照作业提交或进程变为就绪状态的先后次序,分派CPU;</li>
<li>当前作业或进程占用CPU,直到执行完或阻塞,才出让CPU(非抢占方式)。</li>
<li>在作业或进程唤醒后(如I/O完成),并不立即恢复执行,通常等到当前作业或进程出让CPU。最简单的算法。  </li>
</ul>
<h4 id="FCFS的特点"><a href="#FCFS的特点" class="headerlink" title="FCFS的特点"></a>FCFS的特点</h4><ul>
<li>比较有利于长作业,而不利于短作业。</li>
<li>有利于CPU繁忙的作业,不利于I/O繁忙的作业。</li>
</ul>
<h3 id="2-最短作业优先SJF-shortest-job-first"><a href="#2-最短作业优先SJF-shortest-job-first" class="headerlink" title="2.最短作业优先SJF(shortest job first)"></a>2.最短作业优先SJF(shortest job first)</h3><p>这是对FCFS算法的改进，目的是为了缩短平均周转时间。  </p>
<p>对预计执行时间短的作业(进程)优先分派处理机。通常后来的短作业不抢先正在执行的作业。  </p>
<h4 id="SJF的特点"><a href="#SJF的特点" class="headerlink" title="SJF的特点"></a>SJF的特点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h5><ul>
<li>比FCFS改善平均周转时间和平均带权周转时间,缩短作业的等待时间;</li>
<li>提高系统的吞吐量;<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h5></li>
<li>对长作业非常不利,可能长时间得不到执行;</li>
<li>未能依据作业的紧迫程度来划分执行的优先级;</li>
<li>难以准确估计作业(进程)的执行时间,从而影响调度性能。</li>
</ul>
<h3 id="3-轮转调度"><a href="#3-轮转调度" class="headerlink" title="3.轮转调度"></a>3.轮转调度</h3><p>一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为<strong>时间片</strong>，即允许该进程在该时间段内运行。  </p>
<ol>
<li>如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。  </li>
<li>如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。  </li>
</ol>
<h4 id="时间片长度变化的影响"><a href="#时间片长度变化的影响" class="headerlink" title="时间片长度变化的影响"></a>时间片长度变化的影响</h4><ul>
<li>过长-&gt;退化为FCFS算法,进程在一个时间片内都执行完,响应时间长。  </li>
<li>过短-&gt;用户的一次请求需要多个时间片才能处理完,上下文切换次数增加,响应时间长。  </li>
</ul>
<h4 id="时间片长度的确定"><a href="#时间片长度的确定" class="headerlink" title="时间片长度的确定"></a>时间片长度的确定</h4><ol>
<li>系统的响应时间: T(响应时间) = N(进程数目) * q(时间片)</li>
<li>就绪进程的数目: 数目越多,时间片越小</li>
<li>系统的处理能力: 应当使用户输入通常在一个时间片内能处理完,否则使响应时间,平均周转时间和平均带权周转时间延长。</li>
</ol>
<h3 id="4-优先级调度"><a href="#4-优先级调度" class="headerlink" title="4.优先级调度"></a>4.优先级调度</h3><p>基本思想：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。  </p>
<p>优先级又被分为<strong>静态优先级</strong>和<strong>动态优先级</strong>。  </p>
<h4 id="静态优先级"><a href="#静态优先级" class="headerlink" title="静态优先级"></a>静态优先级</h4><p>创建进程时就确定,直到进程终止前都不改变。通常是一个整数。依据:  </p>
<ul>
<li>进程类型(系统进程优先级较高)</li>
<li>对资源的需求(对CPU和内存需求较少的进程,优先级较高)</li>
<li>用户要求(紧迫程度和付费多少)</li>
</ul>
<h4 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h4><p>在创建进程时赋予的优先级,在进程运行过程中可以自动改变,以便获得更好的调度性能。如:  </p>
<ul>
<li>在就绪队列中,等待时间延长则优先级提高,从而使优先级较低的进程在等待足够的时间后,其优先级提高到可被调度执行;</li>
<li>进程每执行一个时间片 就降低其优先级 从而一个进程持续执行时,其优先级降低到出让CPU。</li>
</ul>
<h2 id="三、线程调度"><a href="#三、线程调度" class="headerlink" title="三、线程调度"></a>三、线程调度</h2><p>当若干进程都有多个线程时，就存在两个层次的并行：线程和进程。  </p>
<p>在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或者两者都支持）。  </p>
<h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>因为内核不知道有线程的存在，所以内核还是像以前一样操作，选取一个进程，假设为A，并给予A以时间片控制。A中的线程调度程序决定哪个线程运行，假设为A1。  </p>
<p>由于多道线程并不存在时钟中断，所以这个线程可以随意运行多长时间，如果该线程用完了进程的所有时间片，内核就会选择另外一个进程运行。  </p>
<p>在进程A终于又一次运行时，线程A1会接着运行。该线程会继续耗费A进程的所有时间，直到它完成工作。并且这种行为不会影响到其他的进程。  </p>
<p>现在考虑A线程每次CPU计算的工作比较少的情况，例如在50ms的时间片里有5ms的计算工作。于是，每个线程运行一会儿，然后把CPU交回给线程调度程序。  </p>
<p>这样在内核切换到进程B之前，就会有序列A1,A2,A3,A1,A2,A3,A1,A2,A3,A1。如下图所示。  </p>
<p><img src="/img/user-thread-schedule.png" alt="user"></p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核选取一个特定的线程运行，它不用考虑该线程属于哪个进程（如果有必要它也可以这样做）。内核对被选择的线程赋予一个时间片，如果超出了时间片就会强行挂起这个线程。  </p>
<p>一个线程在50ms的时间片内，5ms之后被阻塞，在30ms的时间段中，线程的顺序会是A1,B1,A2,B2,A3,B3。如下图所示。  </p>
<p><img src="/img/kernel-thread-schedule.png" alt="kernel"></p>
<p><strong>用户级线程和内核级线程之间的差别在于性能。</strong></p>
<ul>
<li><p>用户级线程的线程切换需要少量的机器指令；</p>
</li>
<li><p>内核级线程需要完整的上下文切换，修改内存印象，使高速缓存失效，这导致了若干数量级的延迟。</p>
</li>
</ul>
<p>另一方面，在使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当计算机系统是多道程序设计系统时，通常就会有多个进程或者线程同时竞争CPU。只要有两个或者多个进程处于就绪状态，这种情况就会发生。如果此时只有一个CPU可用，那么就必须选择下一个要运行的进程。&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://thinknight.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="http://thinknight.github.io/2014/OS/communication/"/>
    <id>http://thinknight.github.io/2014/OS/communication/</id>
    <published>2014-10-09T11:02:38.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程经常需要与其他进程通信，所以我们就来讨论一些关于<strong>进程间通信</strong>(Inter Process Communication, IPC)的问题。<br><a id="more"></a></p>
<h2 id="一、竞争状态-race-condition"><a href="#一、竞争状态-race-condition" class="headerlink" title="一、竞争状态(race condition)"></a>一、竞争状态(race condition)</h2><ul>
<li>两个或多个进程对同一共享数据同时进行读写操作，而最后的结果是不可预测的，它取决于各个进程具体运行情况。</li>
<li>在同一时刻，只允许一个进程访问该共享数据，即如果当前已有一个进程正在使用该数据，那么其他进程暂时不能访问。这就是<strong>互斥</strong>的概念。</li>
</ul>
<p>那么为了避免竞争状态，我们就需要<strong>互斥</strong>，也就是当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。这样就引入了临界区的概念。</p>
<h2 id="二、临界区"><a href="#二、临界区" class="headerlink" title="二、临界区"></a>二、临界区</h2><h3 id="临界区的定义："><a href="#临界区的定义：" class="headerlink" title="临界区的定义："></a>临界区的定义：</h3><blockquote>
<p>每个进程中访问临界资源的那段代码称为临界区。<br>临界资源指的是一次只允许一个进程使用的资源称为临界资源，例如打印机、变量。  </p>
</blockquote>
<p>所以如果我们能通过适当的安排，使得两个进程不可能同时处于临界区中，就能避免竞争状态。  </p>
<p>尽管这样的要求避免了竞争状态，但它还不能保证使用共享数据的并发进程能够正确和高效地进行协作。所以对于一个好的解决方案，需要满足一下4个：  </p>
<ol>
<li>任何两个进程都不能同时进入临界区;</li>
<li>不应对CPU的速度和数量做任何假设;</li>
<li>临界区外运行的进程不得阻塞其他进程;</li>
<li>不得使进程无限期等待进入临界区。</li>
</ol>
<h2 id="三、同步机制应遵循的准则"><a href="#三、同步机制应遵循的准则" class="headerlink" title="三、同步机制应遵循的准则"></a>三、同步机制应遵循的准则</h2><h3 id="1-空闲让进"><a href="#1-空闲让进" class="headerlink" title="1.空闲让进"></a>1.空闲让进</h3><ul>
<li>临界自愿处于空闲状态,允许进程进入临界区  </li>
<li>临界区内仅有一个进程执行  </li>
</ul>
<h3 id="2-忙则等待"><a href="#2-忙则等待" class="headerlink" title="2.忙则等待"></a>2.忙则等待</h3><ul>
<li>临界区有进程正在执行其中的代码,所有其他进程则不可以进入临界区  </li>
</ul>
<h3 id="3-有限等待"><a href="#3-有限等待" class="headerlink" title="3.有限等待"></a>3.有限等待</h3><ul>
<li>对要求访问临界区的进程 应在保证在有限时间内进入自己的临界区,避免死等。  </li>
</ul>
<h3 id="4-让权等待"><a href="#4-让权等待" class="headerlink" title="4.让权等待"></a>4.让权等待</h3><ul>
<li>当进程不能进入自己的临界区时,应立即释放处理机,避免忙等。  </li>
</ul>
<h2 id="四、实现互斥的方案"><a href="#四、实现互斥的方案" class="headerlink" title="四、实现互斥的方案"></a>四、实现互斥的方案</h2><h3 id="1-屏蔽中断"><a href="#1-屏蔽中断" class="headerlink" title="1.屏蔽中断"></a>1.屏蔽中断</h3><p>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前打开中断。<br>屏蔽中断后，<strong>时钟中断</strong>也会被屏蔽。<br>CPU只有在发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断后CPU就不会被切换到其他进程。  </p>
<h3 id="2-锁变量"><a href="#2-锁变量" class="headerlink" title="2.锁变量"></a>2.锁变量</h3><p>假设有一个共享变量，初始值为0。当一个进程想进入临界区时，它就会首先测试这把锁。<br>如果锁的值为0，则该进程就将其设置为1并进入临界区。<br>如果锁的值已经为1，那么进程就一直等待直到锁的值为0.<br>所以0就表示临界区内没有进程，1表示已经有某个进程进入临界区。  </p>
<h3 id="3-严格轮换法"><a href="#3-严格轮换法" class="headerlink" title="3.严格轮换法"></a>3.严格轮换法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(TRUE)&#123;</div><div class="line">	<span class="keyword">while</span>(turn != <span class="number">0</span>)</div><div class="line">			critical_region();	<span class="comment">/*循环*/</span></div><div class="line">	turn = <span class="number">1</span>;</div><div class="line">	noncritical_region();</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">&gt;a)  </div><div class="line"></div><div class="line">```<span class="function">C</span></div><div class="line"><span class="title">while</span><span class="params">(TRUE)</span>&#123;</div><div class="line">	<span class="keyword">while</span>(turn != <span class="number">1</span>)</div><div class="line">			critical_region();	<span class="comment">/*循环*/</span></div><div class="line">	turn = <span class="number">0</span>;</div><div class="line">	noncritical_region();</div><div class="line">&#125;</div><div class="line"></div><div class="line">```  </div><div class="line"></div><div class="line">&gt;b)  </div><div class="line"></div><div class="line">### <span class="number">4.</span>Peterson解法</div><div class="line">在进入临界区前，各个进程使用其进程号<span class="number">0</span>或<span class="number">1</span>作为参数来调用enter_region。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作后，进程将调用leave_region，表示操作已完成，若其他进程希望进入临界区，则现在就可以进入。  </div><div class="line"></div><div class="line">```C</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2                                                  <span class="comment">/*进程数量*/</span></span></div><div class="line">                                                                   </div><div class="line"><span class="keyword">int</span> turn;                                                        <span class="comment">/*现在轮到谁？*/</span></div><div class="line"><span class="keyword">int</span> interested[N];                                               <span class="comment">/*所有值初始化为0(FALSE)*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span>                                   <span class="comment">/*进程是0或1*/</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> other;                                                   <span class="comment">/*其他进程号*/</span></div><div class="line">    </div><div class="line">    other = <span class="number">1</span> - process;                                         <span class="comment">/*另一方进程*/</span></div><div class="line">    interested[process] = TRUE;                                  <span class="comment">/*表明所感兴趣的*/</span></div><div class="line">    turn = process;                                              <span class="comment">/*设置标志*/</span></div><div class="line">    <span class="keyword">while</span>(turn == process &amp;&amp; interested[other] == TRUE);         <span class="comment">/*空语句*/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span>                                   <span class="comment">/*进程：谁离开？*/</span></span></div><div class="line">&#123;</div><div class="line">    interested[process] = FALSE;                                 <span class="comment">/*表示离开临界区*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="五、生产者-消费者问题"><a href="#五、生产者-消费者问题" class="headerlink" title="五、生产者-消费者问题"></a>五、生产者-消费者问题</h2><p>生产者-消费者问题又称为<strong>有界缓冲区问题</strong>。两个进程共享一个公共的固定大小的缓冲区。  </p>
<p>其中一个是生产者，将消息放入缓冲区；另一个是消费者，从缓冲区中取出消息。  </p>
<p>而问题在于<strong>当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况</strong>。其解决方法是让生产者睡眠，待消费者从缓存区中取出一个或多个数据项时再唤醒它。</p>
<p>当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100                                      <span class="comment">/*缓冲区中的槽数目*/</span></span></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;                                     <span class="comment">/*缓冲区中的数据项数目*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;                                   <span class="comment">/*无限循环*/</span></div><div class="line">        item = produce_item();                     <span class="comment">/*产生下一新数据项*/</span></div><div class="line">        <span class="keyword">if</span>(count == N)  sleep();                   <span class="comment">/*如果缓冲区满了，就进入休眠状态*/</span></div><div class="line">        insert_item(item);                         <span class="comment">/*将新数据项放入缓冲区中*/</span></div><div class="line">        count = count + <span class="number">1</span>;                         <span class="comment">/*将缓冲区的数据项计数器增1*/</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>）  wakeup(consumer);        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> consumer(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;                                   <span class="comment">/*无限循环*/</span></div><div class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)  sleep();                   <span class="comment">/*如果缓冲区空，则进入休眠状态*/</span></div><div class="line">        item = remove_item();                      <span class="comment">/*从缓冲区中取出一个数据项*/</span></div><div class="line">        count = count - <span class="number">1</span>;                         <span class="comment">/*将缓冲区的数据项计数器减1*/</span></div><div class="line">        <span class="keyword">if</span>(count == N - <span class="number">1</span>)  wakeup(producer);      <span class="comment">/*缓冲区满吗？*/</span></div><div class="line">        consume_item(item);                        <span class="comment">/*打印数据项*/</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">这里还是有可能会出现竞争状态，其原因是对count的访问未加限制。  </div><div class="line"></div><div class="line">我们来看这样一个情况：缓冲区为空，消费者刚刚读取count的值发现它为<span class="number">0</span>，此时调度程序决定暂停消费者而唤醒生产者。生产者向缓冲区中加入一个数据项，count加<span class="number">1</span>。现在count的值变成<span class="number">1</span>了，它推断由于count刚刚为<span class="number">0</span>，所以消费者一定在睡眠，于是生产者调用**wakeup**来唤醒消费者。  </div><div class="line"></div><div class="line">但此时消费者并没有睡眠，所以这个**wakeup**信号就会丢失，当消费者下次运行时，它将测试先前读到的count值，发现它为<span class="number">0</span>，于是睡眠。而生产者迟早会填满整个缓冲区，然后睡眠，这样一来，两个进程将永远睡眠下去。  </div><div class="line"></div><div class="line">所以现在问题的实质在于一个wakeup信号的丢失。虽然在这里我们可以加上一个**唤醒等待位**，但当问题中有三个或者更多进程时一个唤醒等待位就不够了，所以这并没有从本质上解决问题。  </div><div class="line"></div><div class="line">## 六、信号量</div><div class="line">E.W.Dijkstra提出一种方法，它使用一个整型变量来累计唤醒次数，供以后使用。  </div><div class="line"></div><div class="line">这个引入的新变量类型就叫做**信号量(semaphore)**。  </div><div class="line"></div><div class="line">一个信号量的取值可以为<span class="number">0</span>（表示没有保存下来的唤醒操作）或正值（表示有一个或多个唤醒操作）。  </div><div class="line"></div><div class="line">Dijkstra建议设立两种操作：down(P)和up(V)。  </div><div class="line">    </div><div class="line">    </div><div class="line">- down</div><div class="line">    如果信号量的值大于<span class="number">0</span>，则将其值减<span class="number">1</span>并继续；  </div><div class="line">    若该值为<span class="number">0</span>，则进程将睡眠。并将继续down操作。  </div><div class="line"></div><div class="line">- up</div><div class="line">    对信号量的值增<span class="number">1</span>。  </div><div class="line">    </div><div class="line">    </div><div class="line">### 用信号量解决生产者-消费者问题</div><div class="line">#### 该方案使用了三个信号量：</div><div class="line">- **full**   用来记录充满的缓冲槽数目；</div><div class="line">- **empty**  记录空的缓冲槽总数；</div><div class="line">- **mutex**  确保生产者和消费者不会同时访问缓冲区。  </div><div class="line"></div><div class="line">full的初值为<span class="number">0</span>，empty的初值为缓冲区中槽的数目，mutex初值为<span class="number">1</span>。供两个或多个进程使用的信号量，其初值为<span class="number">1</span>，保证同时只有一个进程可以进入临界区，称为二元信号量。如果每个进程在进入临界区前都执行一个down操作，并在刚刚退出时执行一个up操作，就能够实现互斥。  </div><div class="line"></div><div class="line">```C</div><div class="line">#define N <span class="number">100</span>                       <span class="comment">/*缓冲区中的槽数目*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;              <span class="comment">/*信号量是一种特殊的整型数据*/</span></div><div class="line">semaphore mutex = <span class="number">1</span>;                <span class="comment">/*控制对临界区的访问*/</span></div><div class="line">semaphore empty = N;                <span class="comment">/*计数缓冲区的空槽数目*/</span></div><div class="line">semaphore full  = <span class="number">0</span>;                <span class="comment">/*计数缓冲区的满槽数目*/</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;                    <span class="comment">/*TRUE是常量1*/</span></div><div class="line">        item = produce_item();      <span class="comment">/*产生放在缓冲区中的一些数据*/</span></div><div class="line">        down(&amp;empty);               <span class="comment">/*将空槽数目减1*/</span></div><div class="line">        down(&amp;mutex);               <span class="comment">/*进入临界区*/</span></div><div class="line">        insert_item(item);          <span class="comment">/*将新数据项放到缓冲区中*/</span></div><div class="line">        up(&amp;mutex);                 <span class="comment">/*离开临界区*/</span></div><div class="line">        up(&amp;full);                  <span class="comment">/*将满槽的数目加1*/</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> consumer(<span class="keyword">void</span>)</div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;                    <span class="comment">/*无限循环*/</span></div><div class="line">        down(&amp;full);                <span class="comment">/*将满槽数目减1*/</span></div><div class="line">        down(&amp;mutex);               <span class="comment">/*进入临界区*/</span></div><div class="line">        item = remove();            <span class="comment">/*从缓冲区中取出数据项*/</span></div><div class="line">        up(&amp;mutex);                 <span class="comment">/*离开临界区*/</span></div><div class="line">        up(&amp;empty);                 <span class="comment">/*将空槽数加1*/</span></div><div class="line">        consumer_item(item);        <span class="comment">/*处理数据项*/</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程经常需要与其他进程通信，所以我们就来讨论一些关于&lt;strong&gt;进程间通信&lt;/strong&gt;(Inter Process Communication, IPC)的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://thinknight.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="http://thinknight.github.io/2014/OS/process-and-thread/"/>
    <id>http://thinknight.github.io/2014/OS/process-and-thread/</id>
    <published>2014-10-08T13:17:31.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统中最核心的概念就是<strong>进程</strong>：这是对正在运行程序的一个抽象。<br><a id="more"></a></p>
<h2 id="一、进程的定义"><a href="#一、进程的定义" class="headerlink" title="一、进程的定义"></a>一、进程的定义</h2><ul>
<li>进程是程序的一次执行。  </li>
<li>进程 = 进程控制块 + 程序 + 数据。  </li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。  </li>
</ul>
<h2 id="二、进程的结构"><a href="#二、进程的结构" class="headerlink" title="二、进程的结构"></a>二、进程的结构</h2><p>一个进程中应该包括：  </p>
<ul>
<li>程序的代码；</li>
<li>程序的数据；</li>
<li>程序计数器中的值，用来指示下一条将运行的指令；</li>
<li>一组通用的寄存器的当前值、堆、栈；</li>
<li>一组系统资源（如打开的文件）；</li>
</ul>
<h2 id="三、进程的创建：4个因素"><a href="#三、进程的创建：4个因素" class="headerlink" title="三、进程的创建：4个因素"></a>三、进程的创建：4个因素</h2><p>1.系统初始化。<br>2.执行了正在运行的进程所调用的进程创建系统调用。<br>3.用户请求创建一个新进程。<br>4.一个批处理作业的初始化。</p>
<blockquote>
<p>在UNIX系统中，只有一个系统调用可以用来创建新进程：<strong>fork</strong>。</p>
</blockquote>
<h2 id="四、进程的终止：4种原因"><a href="#四、进程的终止：4种原因" class="headerlink" title="四、进程的终止：4种原因"></a>四、进程的终止：4种原因</h2><ol>
<li>正常退出（自愿的）。</li>
<li>出错退出（自愿的）。</li>
<li>严重错误（非自愿）。</li>
<li>被其他进程杀死（非自愿）。</li>
</ol>
<h2 id="五、进程的状态"><a href="#五、进程的状态" class="headerlink" title="五、进程的状态"></a>五、进程的状态</h2><p>进程有三种基本状态：  </p>
<ul>
<li>运行态<br>该时刻进程实际占用CPU。</li>
<li>就绪态<br>可运行，但因为其他进程正在运行而暂时停止。<br>进程已获得除处理机外的所需资源，等待分配处理机资源，只要分配CPU就可执行。</li>
<li>阻塞态<br>正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。  </li>
</ul>
<p>1.运行→阻塞：进程为等待输入而阻塞<br>2.运行→就绪：调度进程选择另一个程序<br>3.就绪→运行：调度进程选择这个进程<br>4.阻塞→就绪：出现有效输入</p>
<ul>
<li>在操作系统发现进程不能继续运行下去时，发生转换1。  </li>
<li>系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2。  </li>
<li>在系统已经让所有其他进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会发生转换3。  </li>
<li>当进程等待的一个外部事件发生时（如一些输入达到），则发生转换4。  </li>
</ul>
<p>转换2、3都是由<strong>进程调度程序</strong>引起的。</p>
<p><strong>调度程序</strong>的主要工作就是决定<strong>应当运行哪个进程</strong>、<strong>何时运行</strong>以及<strong>它应该运行多长时间</strong>。</p>
<p><img src="/img/process.png" alt="process"></p>
<h2 id="六、进程的实现"><a href="#六、进程的实现" class="headerlink" title="六、进程的实现"></a>六、进程的实现</h2><p>操作系统为了实现进程模型，维护着一张叫做<strong>进程表</strong>(process table)的表格，每个进程占用一个<strong>进程表项</strong>。（在学校的教材上这个进程表项叫做<strong>进程控制块</strong>PCB）。  </p>
<blockquote>
<p><strong>进程控制块PCB</strong>是进程的唯一标志。</p>
</blockquote>
<p>进程控制块中包含了进程状态的重要信息，包括：  </p>
<ul>
<li>程序计数器（PC）</li>
<li>堆栈指针</li>
<li>内存分配状态</li>
<li>所打开文件状态</li>
<li>账号和调度信息</li>
<li>优先级</li>
<li>互斥和同步机制</li>
<li>…</li>
</ul>
<p>正是这些信息保证了进程在经历了各种转换后能再次启动，就像从未被中断过一样。</p>
<hr>
<h2 id="七、线程"><a href="#七、线程" class="headerlink" title="七、线程"></a>七、线程</h2><p>上面的内容中，我们讨论了关于进程的话题，但是在实际运用当中并不是每次都只运行一个进程的，所以我们就需要提出一个新的实体，来满足一下特性：  </p>
<ul>
<li>实体之间可以并发地执行；</li>
<li>实体之间共享相同的地址空间；</li>
</ul>
<p>而进程包含了两个概念：<strong>资源拥有者</strong>和<strong>可执行单元</strong>，这个可执行单元就称为<strong>线程</strong>。</p>
<p>尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。  </p>
<blockquote>
<p>进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。  </p>
</blockquote>
<p><strong>在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。</strong>  </p>
<ol>
<li>在前一种情形中，多个线程共享同一个地址空间和其他资源。  </li>
<li>在后一种情形下，多个进程共享物理内存、磁盘、打印机个和其他资源。  </li>
</ol>
<h2 id="八、引入线程的目的"><a href="#八、引入线程的目的" class="headerlink" title="八、引入线程的目的"></a>八、引入线程的目的</h2><ul>
<li>减小进程切换的开销</li>
<li>提高进程内的并发程度</li>
<li>共享资源</li>
</ul>
<p>那么问题来了，引入进程和线程的好处分别是什么？  </p>
<ul>
<li>引入进程的好处<br>  多个程序可以并发执行，改善资源使用率，提高系统效率。  </li>
<li>引入线程的好处<br>  减少并发程序执行时所付出的时空开销，使得并发粒度更细，并发性更好。  </li>
</ul>
<h2 id="九、多线程的原因："><a href="#九、多线程的原因：" class="headerlink" title="九、多线程的原因："></a>九、多线程的原因：</h2><p>1.主要原因是，在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞，通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。<br>2.线程比进程更加轻量级，所以线程比进程更加容易（更快）创建和撤销。<br>3.如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动重叠进行，从而加快应用程序的执行速度。<br>4.在多CPU系统中，多线程是有益的，并且真正的并行有了实现的可能。  </p>
<h2 id="十、线程中包括："><a href="#十、线程中包括：" class="headerlink" title="十、线程中包括："></a>十、线程中包括：</h2><ul>
<li>程序计数器：记录接着要执行哪一条指令。</li>
<li>寄存器：保存线程当前的工作变量。</li>
<li>堆栈：记录执行历史。</li>
</ul>
<blockquote>
<p>线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。  </p>
</blockquote>
<h2 id="十一、线程的实现"><a href="#十一、线程的实现" class="headerlink" title="十一、线程的实现"></a>十一、线程的实现</h2><h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，这样用户级线程包可以在不支持线程的操作系统上实现，通过这一方法就可以用函数库实现线程。</p>
<p><img src="/img/user-thread.png" alt="user-thread"></p>
<pre><code class="C"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span>

<span class="meta">#<span class="meta-keyword">define</span> NUMBER_OF_THREADS 10</span>

<span class="function"><span class="keyword">void</span> *<span class="title">print_hello_world</span><span class="params">(<span class="keyword">void</span> *tid)</span>
</span>{
    <span class="comment">/*本函数输出线程的标识符，然后退出。*/</span>
    <span class="built_in">printf</span>(<span class="string">"Hello World.Greetings from thread %d0"</span>, tid);
    pthread_exit(<span class="literal">NULL</span>);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span>
</span>{
    <span class="comment">/*主程序创建10个进程，然后退出。*/</span>
    <span class="keyword">pthread_t</span> threads[NUMBER_OF_THREADS];
    <span class="keyword">int</span> status, i;

    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUMBER_OF_THREADS; i++){
        <span class="built_in">printf</span>(<span class="string">"Main here.Creating thread %d0\n"</span>, i);
        status = pthread_creat(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="keyword">void</span> *)i);

        <span class="keyword">if</span>(status != <span class="number">0</span>){
            <span class="built_in">printf</span>(<span class="string">"Oops.pthread_creat return error code %d0"</span>, status);
            <span class="built_in">exit</span>(<span class="number">-1</span>);
        }
    }
    <span class="built_in">exit</span>(<span class="literal">NULL</span>);
}
</code></pre>
<h4 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h4><p>内核级线程就是内核有好几个分身，一个分身可以处理一件事的意思。这用来处理非同步事件很有用, 内核可以对每个非同步事件生个分身来处理。  </p>
<p>内核级线程的操作非常轻便,几乎没有负担,而且对内核的结构有帮助。支持内核级线程的内核称作多线程内核。  </p>
<p><img src="/img/kernel-thread.png" alt="kernel-thread"></p>
<blockquote>
<p>例子：Windows 95/98/NT/2000, Solaris,Tru64 UNIX,Linux</p>
</blockquote>
<hr>
<p>以上的内容只是对进程与线程的概念以及一些其他的基础问题做了简单的阐述，在操作系统中关于进程内容的核心知识还得是<strong>进程的调度与通信</strong>，这两个问题留到下一篇讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统中最核心的概念就是&lt;strong&gt;进程&lt;/strong&gt;：这是对正在运行程序的一个抽象。&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://thinknight.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣爬虫</title>
    <link href="http://thinknight.github.io/2014/Python/douban-crawler/"/>
    <id>http://thinknight.github.io/2014/Python/douban-crawler/</id>
    <published>2014-08-28T07:08:40.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>可抓取豆瓣读书、电影、音乐中任意标签下内容<br><a id="more"></a></p>
<p>在我刚刚入门Python爬虫的时候，无论怎样都很难找到一个适当的实例让我参考。  </p>
<p>看过很多别人的例子，但都觉得不得要领，所以在折腾很久后写了这个简单的例子。  </p>
<hr>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 如果要在python2的py文件里面写中文，则必须要添加一行声明文件编码的注释，否则python2会默认使用ASCII编码。  </span></div><div class="line"></div><div class="line"><span class="keyword">import</span> re </div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">douban_crawler</span><span class="params">(url_head, target)</span>:</span></div><div class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">20</span>):</div><div class="line">    <span class="comment">#这个1000是检索的条目数量，可以按需设定</span></div><div class="line">        url_rear = <span class="string">"?start=%d&amp;type=T"</span> % page</div><div class="line">        url_use = url_head + url_rear</div><div class="line">        <span class="comment">#两段合成真正的url</span></div><div class="line">        content = urllib2.urlopen(url_use).read()</div><div class="line">        content = content.decode(<span class="string">"UTF-8"</span>).encode(<span class="string">"UTF-8"</span>)</div><div class="line">        </div><div class="line">        content = content.replace(<span class="string">r'title="去FM收听"'</span>, <span class="string">""</span>)</div><div class="line">        content = content.replace(<span class="string">r'title="去其他标签"'</span>, <span class="string">""</span>)</div><div class="line">        </div><div class="line">        name = re.findall(<span class="string">r'title="(\S*?)"'</span>, content, re.S)</div><div class="line">        <span class="comment">#正则表达式捕获标题</span></div><div class="line">        num  = re.findall(<span class="string">r'&lt;span\s*class="rating_nums"&gt;([0-9.]*)&lt;\/span&gt;'</span>, content)</div><div class="line">        <span class="comment">#正则表达式捕获分数</span></div><div class="line">        </div><div class="line">        doc = zip(name, num)</div><div class="line">        <span class="comment">#将标题和分数打包成([ , ][ , ]...)的形式</span></div><div class="line">        <span class="keyword">if</span> target == <span class="string">"book"</span>:</div><div class="line">            dou = open(<span class="string">"doc_book.txt"</span>, <span class="string">'a'</span>)</div><div class="line">        <span class="keyword">elif</span> target == <span class="string">"music"</span>:</div><div class="line">            dou = open(<span class="string">"doc_music.txt"</span>, <span class="string">'a'</span>)</div><div class="line">        <span class="keyword">elif</span> target == <span class="string">"movie"</span>:</div><div class="line">            dou = open(<span class="string">"doc_movie.txt"</span>, <span class="string">'a'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> doc:</div><div class="line">            dou.write(i[<span class="number">0</span>] + <span class="string">" "</span> + i[<span class="number">1</span>] + <span class="string">"\n"</span>)</div><div class="line">            <span class="comment">#写入</span></div><div class="line">    dou.close()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    target = raw_input(<span class="string">"豆瓣 book movie music，你想爬哪一个? "</span>)</div><div class="line"></div><div class="line">    tag   = raw_input(<span class="string">"请输入你想要检索的标签: "</span>)</div><div class="line"></div><div class="line">    url_head  = <span class="string">"http://%s.douban.com/tag/%s"</span> % (target, tag)</div><div class="line"></div><div class="line">    douban_crawler(url_head, target)</div><div class="line">    </div><div class="line">    <span class="keyword">print</span> <span class="string">"抓取完毕"</span></div></pre></td></tr></table></figure>
<h3 id="抓取结果"><a href="#抓取结果" class="headerlink" title="抓取结果"></a>抓取结果</h3><ul>
<li><strong>豆瓣读书-小说</strong></li>
</ul>
<blockquote>
<p>月亮和六便士 9.0<br>百年孤独 9.2<br>解忧杂货店 8.7<br>追风筝的人 8.8<br>霍乱时期的爱情 9.0<br>平凡的世界（全三部） 9.0<br>围城 8.9<br>活着 9.1<br>一九八四 9.3<br>人生的枷锁 9.0<br>陆犯焉识 8.7<br>…  </p>
</blockquote>
<ul>
<li><strong>豆瓣电影-悬疑</strong></li>
</ul>
<blockquote>
<p>盗梦空间 9.2<br>寒战 7.4<br>嫌疑人X的献身 7.4<br>七宗罪 8.7<br>致命ID 8.5<br>云图 8.0<br>禁闭岛 8.5<br>蝴蝶效应 8.6<br>致命魔术 8.8<br>恐怖游轮 8.2<br>…</p>
</blockquote>
<ul>
<li><strong>豆瓣音乐-pop</strong></li>
</ul>
<blockquote>
<p>十二新作 8.2<br>Alright,Still 7.7<br>范特西 8.5<br>Apologize 8.9<br>逆光 7.3<br>Spin 8.5<br>阿岳正传 8.3<br>感官/世界 8.7<br>八度空间 7.5<br>PCD 8.4<br>…</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可抓取豆瓣读书、电影、音乐中任意标签下内容&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://thinknight.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>操作系统名词概念解释</title>
    <link href="http://thinknight.github.io/2014/OS/os-1/"/>
    <id>http://thinknight.github.io/2014/OS/os-1/</id>
    <published>2014-06-21T14:07:20.000Z</published>
    <updated>2017-07-02T11:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单解释一些容易混淆的学术性名词。<br><a id="more"></a></p>
<h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><ul>
<li>指系统在单位时间内所完成的总工作量    </li>
</ul>
<h2 id="作业的周转时间"><a href="#作业的周转时间" class="headerlink" title="作业的周转时间"></a>作业的周转时间</h2><ul>
<li>指从作业进入系统开始，直至其完成并退出系统为止所经历的时间  </li>
</ul>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><ul>
<li>批处理(batch processing )就是将作业按照它们的性质分组（或分批），然后再成组（或成批）地提交给计算机系统，由计算机自动完成后再输出结果，从而减少作业建立和结束过程中的时间浪费。  </li>
</ul>
<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><ul>
<li>单道批处理系统<br>内存中永远仅有一道作业的批处理操作系统称为单道批处理系统</li>
<li>多道批处理系统<br>内存中可同时存在若干道作业的批处理操作系统称为多道批处理系统<br>用户所提交的作业都先存放在外存上并排成一个队列，称为”后备队列”，然后作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使他们共享CPU和系统中的各种资源。</li>
</ul>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><ul>
<li>利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</li>
</ul>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><ul>
<li><p>系统特征是将时间作为关键参数。<br>能够在”指定”或者”确定”的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统,实时意思就是对响应时间有严格要求,要以足够快的速度进行处理.分为硬实时和软实时两种。  </p>
</li>
<li><p>硬实时：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p>
</li>
<li>软实时：虽然也联系着一个截止时间，但是超过了也可以接受，并且不会引起任何永久性的损害。</li>
</ul>
<h2 id="处理机与处理器"><a href="#处理机与处理器" class="headerlink" title="处理机与处理器"></a>处理机与处理器</h2><ul>
<li><p>处理机：计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位。处理机包括中央处理器，主存储器,I/O接口。  </p>
</li>
<li><p>处理器：即中央处理器（CPU），其功能主要是解释计算机指令以及处理计算机软件中的数据。  </p>
</li>
</ul>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul>
<li>并行指两个或多个事件在同一时刻发生</li>
<li>并发指两个或多个事件在同一时间间隔内发生</li>
</ul>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><ul>
<li>是指从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。  </li>
<li>地址空间里存放可执行程序、程序的数据、程序的堆栈。  </li>
</ul>
<h2 id="从概率的角度来看CPU的利用率"><a href="#从概率的角度来看CPU的利用率" class="headerlink" title="从概率的角度来看CPU的利用率"></a>从概率的角度来看CPU的利用率</h2><p>假设一个进程等待I/O操作的时间与其停留在内存中时间的比为P。当内存中同时有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p^n。CPU的利用率为：  </p>
<blockquote>
<p>CPU利用率 = 1 - p^n</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单解释一些容易混淆的学术性名词。&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://thinknight.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>简单分治</title>
    <link href="http://thinknight.github.io/2014/Algorithm/divide-and-conquer/"/>
    <id>http://thinknight.github.io/2014/Algorithm/divide-and-conquer/</id>
    <published>2014-03-24T09:54:45.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的排序算法中，我们提到了一种叫归并排序的算法，就是通过把待排序的数列分成一个个小的数列并排序成有序表，再将这些小的有序表组合成一个新的有序表来完成排序，所以归并排序算法就是利用分治策略的一个很好的典型。<br><a id="more"></a></p>
<h1 id="概念阐述"><a href="#概念阐述" class="headerlink" title="概念阐述"></a>概念阐述</h1><p>在分治策略中我们用递归的方法来求解一个问题，在每一层的递归中应用如下的三个步骤：</p>
<ul>
<li>分解(Dived)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li>解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并(Combine)步骤将子问题的解组合成原问题的解。  </li>
</ul>
<p>简单通俗地来说，所谓的<strong>分治策略</strong>就是把很复杂的问题用递归的方式细化成一个个小的，能够解决子问题，再把所有子问题的解合并起来，就得到原问题的解。  </p>
<p>下面就通过一个例子来简单介绍分治策略。  </p>
<h1 id="实例问题"><a href="#实例问题" class="headerlink" title="实例问题"></a>实例问题</h1><p>这里有一个数组A：</p>
<blockquote>
<p><code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>  </p>
</blockquote>
<p>现在要求寻找数组A中和最大的非空连续子数组（我们称这样的连续子数组为<strong>最大子数组</strong>）。</p>
<h2 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h2><p>乍一看到这个问题，首先想到的当然就是简单粗暴地套上双重循环，尝试每对可能的组合，再进行比较，得出最终结果，这就是我们常说的暴力求解法，算法实现如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最大子数组问题：暴力求解法</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>,     <span class="number">22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span> &#125;;</div><div class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>( A ) / <span class="keyword">sizeof</span>( <span class="keyword">int</span> );</div><div class="line">    <span class="keyword">int</span> max = <span class="number">-1000</span>;</div><div class="line">    <span class="keyword">int</span> i, j, k, sum, step, left;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt;= length; i++ ) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; ( j + i <span class="number">-1</span> ) &lt;= length<span class="number">-1</span>; j++ )  </div><div class="line">        &#123;</div><div class="line">            sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>( k = j; k &lt;= j + i - <span class="number">1</span>; k++ ) </div><div class="line">                sum += A[ k ];</div><div class="line">            <span class="keyword">if</span>( sum &gt; max )</div><div class="line">            &#123;</div><div class="line">                max = sum;</div><div class="line">                left = j;</div><div class="line">                step = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"length:%d, max:%d, left:%d, right:%d, step:%d\n"</span>, length, max, left, left+step<span class="number">-1</span>, step);</div><div class="line">    getchar();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">但是套上两个循环后，算法的时间复杂度就变为了O(n²)，我们还有更好的方法。  </div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## 分治策略求解法</div><div class="line"></div><div class="line">现在我们假设要寻找子数组`A[low..high]`的最大子数组，使用分治就意味着要把数组A分成两个规模尽量相等的子数组，也就是说找到数组的中央位置mid，然后考虑求解两个子数组`A[low..mid]`和`A[mid+<span class="number">1.</span>.high]`。这时的最大子数组`A[i..j]`所在的位置必然是如下三处：</div><div class="line">- 完全处于子数组`A[low..mid]`中，因此 `low ≤ i ≤ j ≤ mid`。</div><div class="line">- 完全处于子数组`A[mid+<span class="number">1.</span>.high]`中，因此 `mid+<span class="number">1</span> ≤ i ≤ j ≤ high`。</div><div class="line">- 跨越了中点mid，因此 `low≤ i ≤ mid &lt; j ≤ high`。  </div><div class="line"></div><div class="line">接下来我们就可以递归地求解数组`A[low..mid]`和`A[mid+<span class="number">1.</span>.high]`的最大子数组，因为这两个子问题仍然是最大子数组问题，只是规模更小，因此剩下的子工作就是在这三个子数组的最大子数组中找出最大的一个。</div><div class="line"></div><div class="line">任何跨中点的最大子数组都由两个子数组`A[i..mid]`和`A[mid+<span class="number">1.</span>.j]`组成，其中low≤ i ≤ mid且mid &lt; j ≤ high，因此只要找到形如`A[i..mid]`和`A[mid+<span class="number">1.</span>.j]`的最大子数组，然后将其合并即可，对此算导给出了如下的伪代码：</div></pre></td></tr></table></figure>
<p>FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high )<br>    left-sum = -100000<br>    sum = 0<br>    for i = mid downto low<br>        sum = sum + A[i]<br>        if sum &gt; left-sum<br>            left-sum = sum<br>            max-left = i</p>
<pre><code>right-sum = -100000
sum = 0
for j = mid + 1 to high
    sum = sum + A[i]
    if sum &gt; right-sum
        right-sum = sum
        max-right = j

return (max-left, max-right, left-sum + right-sum)
</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"></div><div class="line"><span class="string">有了线性时间的FIND-MAX-CROSSING-SUBARRRY，我们就可以设计求解最大子数组问题的分治算法的伪代码：</span>  </div><div class="line"></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure>
<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br>if high == low<br>    return ( low, high, A[low] );<br>else<br>    mid = ( low + high ) / 2<br>    ( left-low, left-high, left-sum ) =<br>        FIND-MAXIMUM-SUBARRAY( A, low, mid )<br>    ( right-low, right-high, right-sum ) =<br>        FIND-MAXIMUM-SUBARRAY( A, mid + 1, high )<br>    ( cross-low, cross-high, cross-sum ) =<br>        FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high )<br>    if left-sum &gt;= right-sum and left-sum &gt;= cross-sum<br>        return ( left-low, left-high, left-sum )<br>    elseif right-sum &gt;= left-sum and right-sum &gt;= cross-sum<br>        return ( right-low, right-high, right-sum )<br>    else<br>        return ( cross-low, cross-high, cross-sum )<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"></div><div class="line"><span class="string">具体实现代码如下：</span>  </div><div class="line"></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure></p>
<p>//最大子数组问题：分治策略法</p>
<p>#include <stdio.h><br>int last_low, last_high;</stdio.h></p>
<p>int<br>find_max_cro_arr( int A[], int low, int mid, int high )<br>{<br>    int i, j;<br>    int left_sum = -100000;<br>    int sum = 0;<br>    for( i = mid; i &gt;= low; i– ){<br>        sum += A[ i ];<br>        if( sum &gt; left_sum )<br>        {<br>            left_sum = sum;<br>            last_low = i;<br>        }<br>    }</p>
<pre><code>int right_sum = -100000;
sum = 0;
for( j = mid + 1; j &lt;= high; j++ ){
    sum = sum + A[ j ];
    if( sum &gt; right_sum )
    {
        right_sum = sum;
        last_high = j;
    }    
}
return left_sum + right_sum;
</code></pre><p>}</p>
<p>int<br>find_max_arr( int A[], int low, int high )<br>{<br>    int left_sum, right_sum, cross_sum;<br>    if( high == low )<br>        return A[ low ];<br>    else<br>    {<br>        int mid = ( low + high ) / 2;<br>        left_sum = find_max_arr( A, low, mid );<br>        right_sum = find_max_arr( A, mid + 1, high );<br>        cross_sum = find_max_cro_arr( A, low, mid, high );<br>        if ( left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum )<br>            return left_sum;<br>        else if ( right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum )<br>                return right_sum;<br>            else<br>                return cross_sum;    </p>
<pre><code>}
</code></pre><p>}</p>
<p>int<br>main()<br>{<br>    int A[] = { 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 };<br>    int length = sizeof( A ) / sizeof( int );<br>    int sum = find_max_arr( A, 0, length - 1 );<br>    printf(“max_sum:%d, low:%d, high:%d\n”, sum, last_low, last_high);</p>
<pre><code>getchar();
return 0;
</code></pre><p>}<br>```  </p>
<p>参考资料：《算法导论：第三版》。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的排序算法中，我们提到了一种叫归并排序的算法，就是通过把待排序的数列分成一个个小的数列并排序成有序表，再将这些小的有序表组合成一个新的有序表来完成排序，所以归并排序算法就是利用分治策略的一个很好的典型。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://thinknight.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（二）</title>
    <link href="http://thinknight.github.io/2014/Algorithm/sort2/"/>
    <id>http://thinknight.github.io/2014/Algorithm/sort2/</id>
    <published>2014-03-04T14:20:39.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了几种简单的排序算法，这一篇来谈谈<strong>归并排序</strong>和<strong>快速排序</strong>。<br><a id="more"></a></p>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>顾名思义，归并算法就是将两个或两个以上的有序表组合成一个新的有序表，所以归并排序算法是递归算法的一个很好的实例。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>归并操作的过程如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾  </li>
</ol>
<p>举个例子吧:  </p>
<blockquote>
<p><code>[ 10 4 6 3 8 2 5 7 ]</code><br><code>[ 10 4 6 3 ]   [ 8 2 5 7 ]</code><br><code>[ 10 4 ]  [ 6 3 ]  [ 8 2 ]  [ 5 7 ]</code><br><del><code>[ 10 ] [ 4 ] [ 6 ] [ 3 ] [ 8 ] [ 2 ] [ 5 ] [ 7 ]</code></del><br><code>[ 4 10 ]  [ 3 6  ] [ 2 8 ]  [ 5 7 ]</code><br><code>[ 3 4 6 10 ]  [ 2 5 7 8 ]</code><br><code>[ 2 3 4 5 6 7 8 10 ]</code>  </p>
</blockquote>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul>
<li><p>最差时间复杂度：O(nlogn)  </p>
</li>
<li><p>最优时间复杂度：O(n)  </p>
</li>
<li><p>平均时间复杂度：O(nlogn)  </p>
</li>
</ul>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>归并排序是一种稳定的排序方法  </p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="C"><span class="comment">//归并排序</span>
<span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;

<span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Lpos, <span class="keyword">int</span> Rpos, <span class="keyword">int</span> RightEnd )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">Mergesort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>;

<span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Lpos, <span class="keyword">int</span> Rpos, <span class="keyword">int</span> RightEnd )</span>
</span>{
    <span class="keyword">int</span> i, LeftEnd, NumElements, TmpPos;
    LeftEnd = Rpos - <span class="number">1</span>;
    TmpPos = Lpos;
    NumElements = RightEnd - Lpos + <span class="number">1</span>;

    <span class="keyword">while</span>( Lpos &lt;= LeftEnd &amp;&amp; Rpos &lt;= RightEnd )
        <span class="keyword">if</span>( A[ Lpos ] &lt;= A[ Rpos ] )
            TmpArray[ TmpPos++ ] = A[ Lpos++ ];
        <span class="keyword">else</span>
            TmpArray[ TmpPos++ ] = A[ Rpos++ ];

    <span class="keyword">while</span>( Lpos &lt;= LeftEnd )
        TmpArray[ TmpPos++ ] = A[ Lpos++ ];
    <span class="keyword">while</span>( Rpos &lt;= RightEnd )
        TmpArray[ TmpPos++ ] = A[ Rpos++ ];

    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NumElements; i++, RightEnd-- )
        A[ RightEnd ] = TmpArray[ RightEnd ];
}

<span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span>
</span>{
    <span class="keyword">int</span> Center;

    <span class="keyword">if</span>( Left &lt; Right )
    {
        Center = ( Left + Right ) / <span class="number">2</span>;
        MSort( A, TmpArray, Left, Center );
        MSort( A, TmpArray, Center + <span class="number">1</span>, Right );
        Merge( A, TmpArray, Left, Center + <span class="number">1</span>, Right );
    }
}

<span class="function"><span class="keyword">void</span> <span class="title">Mergesort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span>
</span>{
    ElemType *TmpArray;

    TmpArray = <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( ElemType ));
    <span class="keyword">if</span>( TmpArray != <span class="literal">NULL</span>)
    {
        MSort( A, TmpArray, <span class="number">0</span>, N - <span class="number">1</span> );
        <span class="built_in">free</span>( TmpArray );
    }
    <span class="keyword">else</span>
        <span class="built_in">printf</span>(<span class="string">"No space for tmp array!!!"</span>);
}
</code></pre>
<p>虽然归并排序的运行时间是O（nlogn），但是它很难用于主存排序，主要问题在于合并两个排序的表需要线性附加内存，在整个算法中还要花费将数据拷贝到临时数组再拷贝回来这样一些附加的工作，其结果严重放慢了排序的速度。</p>
<p>归并排序不仅可以用分治的策略来递归处理，也可以用迭代的方法来表示，但即使这样，对于重要的内部排序而言，人们还是选择快速排序。  </p>
<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>正如它的名字所标示的，快速排序是在实践中已知的最快排序算法，该算法特别快，主要是由于非常精炼和高度优化的内部循环。像归并排序一样，快速排序也是一种分治的递归算法。  </p>
<h2 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h2><p>将数组S排序的基本算法由下列简单的4步组成：</p>
<ol>
<li>如果S中元素个数是0或1，则返回。</li>
<li>取S中任一元素，称之为枢纽元。</li>
<li>将A = S - {v}(S中其余元素)分成两个不相交的集合：S1 = { x属于A | x &lt;= v } 和S2= { x属于A | x &gt;= v }。</li>
<li>返回{quicksort(S1)后，继随v,继而quicksort(S2)}.</li>
</ol>
<p>下面给出一个乱序的数组<code>{[ 50 10 90 30 70 40 80 60 20 }</code>，以第一个元素<code>50</code>为枢纽元，来展现快速排序的过程。</p>
<blockquote>
<p><code>[ (50) 10 90 30 70 40 80 60 (20) ]</code> 第1次交换  </p>
<p><code>[ (20) 10 90 30 70 40 80 60 (50) ]</code> 第2次交换  </p>
<p><code>[ 20 10 (50) 30 70 40 80 60 (90) ]</code> 第3次交换  </p>
<p><code>[ 20 10 (40) 30 70 (50) 80 60 90 ]</code> 第4次交换  </p>
<p><code>[ 20 10 40 30 (50) (70) 80 60 90 ]</code> 第5次交换  </p>
<p><code>[ 20 10 40 30 （50）70 80 60 90 ]</code>  第6次交换  </p>
</blockquote>
<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><ul>
<li>最差时间复杂度：O(n²)</li>
<li>最优时间复杂度：O(nlogn)</li>
<li>平均时间复杂度：O(nlogn)  </li>
</ul>
<h2 id="算法稳定性-1"><a href="#算法稳定性-1" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>快速排序是一种稳定的排序方法  </p>
<h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="C"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;

<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>;

<span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span>
</span>{
    QSort( A, <span class="number">0</span>, N - <span class="number">1</span> );
}

<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span>
</span>{
    <span class="keyword">int</span> Tmp;
    Tmp = A[ a ];
    A[ a ] = A[ b ];
    A[b] = Tmp;
}

<span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span>
</span>{
    <span class="keyword">int</span> pivot;

    <span class="keyword">if</span>( low &lt; high )
    {
        pivot = Partition( A, low, high );
        QSort( A, low, pivot<span class="number">-1</span> );
        QSort( A, pivot+<span class="number">1</span>, high );
    }
}

<span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span>
</span>{
    <span class="keyword">int</span> pivotkey;
    pivotkey = A[ low ];
    <span class="keyword">while</span>( low &lt; high )
    {
        <span class="keyword">while</span>( low &lt; high &amp;&amp; A[ high ] &gt;= pivotkey )
            high--;
        swap(A, low, high);
        <span class="keyword">while</span>( low &lt; high &amp;&amp; A[ low ] &lt;= pivotkey)
            low++;
        swap(A, low, high);
    }
    <span class="keyword">return</span> low;
}
</code></pre>
<hr>
<p>排序算法的内容就差不多先写到这里了，其实学习算法，光能用代码写出算法和理解原理只是初步的学习，最近看了《算法导论》才认识到，一个算法不光光只像这两篇文章里写的内容那么简单，还包含各自复杂的数学证明和进一步的优化，我的学习还有待继续深入！  </p>
<h1 id="舞动的排序算法"><a href="#舞动的排序算法" class="headerlink" title="舞动的排序算法"></a>舞动的排序算法</h1><p>如果光看文字还理解不了算法原理的话，这里有一组用舞蹈的形式来展现排序算法的原理的视频。  </p>
<ul>
<li><a href="http://v.youku.com/v_show/id_XMzMyOTAyMzQ0.html?f=16755664" target="_blank" rel="external">冒泡排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5Njg4.html?f=16755664" target="_blank" rel="external">归并排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5MzI4.html?f=16755664" target="_blank" rel="external">希尔排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5MDI0.html?f=16755664" target="_blank" rel="external">选择排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk4NTQ4.html?f=16755664" target="_blank" rel="external">快速排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk3NjI4.html?f=16755664" target="_blank" rel="external">插入排序</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了几种简单的排序算法，这一篇来谈谈&lt;strong&gt;归并排序&lt;/strong&gt;和&lt;strong&gt;快速排序&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://thinknight.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（一）</title>
    <link href="http://thinknight.github.io/2014/Algorithm/sort/"/>
    <id>http://thinknight.github.io/2014/Algorithm/sort/</id>
    <published>2014-03-02T13:27:12.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>回顾基础的排序算法<br><a id="more"></a></p>
<p>在数据结构这门课程里，学校的老师们是较侧重于教学生如何利用诸如C语言来实现线性表，队列，栈，树这些简单的数据结构，理解这些数据结构的用法，而往往轻视了后半块关于图论，排序，查找等偏算法分析方面的内容的教学。  </p>
<p>虽然课程的名字叫做数据结构，但很多CS强校和国外的著作都习惯地把它称作“数据结构与算法分析”。说到底，数据结构只能算是对编程语言使用的一个延伸，很多程序设计入门书诸如《C Primer Plus》和《C和指针》的后半段都会谈一些链表，树等内容，所以现在回过头来看，前面数据结构的学习还是为了在后面实现一些复杂的算法的时候，能够更好地利用这些结构来处理数据和实现算法中的思想。  </p>
<p>在期末考试中，我们最后的大题目往往都是解答题，要求学生用编程语言实现诸如快速排序这样的算法，那么这样来看的话，独立实现这些复杂的算法，便就是真正考验这门课程是否学好的重要标准之一。  </p>
<p>这一篇就先回顾<strong>排序算法</strong>。  </p>
<hr>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种比较简单的排序算法，通常被用来对于刚入门学习程序设计的学生介绍算法的概念。  </p>
<h2 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><ul>
<li><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数(n-1)和记录移动次数(0)均达到最小值。<br>所以，冒泡排序最好的时间复杂度为O(n)。 </p>
</li>
<li><p>若初始文件是反序的，需要进行趟排序。每趟排序要进行次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：O(n²)</p>
</li>
<li><p>冒泡排序的最坏时间复杂度为O(n²)。  </p>
</li>
</ul>
<p>综上，因此冒泡排序总的平均时间复杂度为O(n²)。</p>
<h2 id="算法稳定性："><a href="#算法稳定性：" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>由于冒泡算法的核心思想就是把小的元素往前调，大的元素往后调，相同的元素不做处理，所以即使相同的元素中间还隔着其他元素，这两个元素也不会发生交换，所以冒泡排序是一种稳定的排序算法。  </p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    ElemType Tmp;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</div><div class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>( A[ j ] &gt; A[ j + <span class="number">1</span>] )</div><div class="line">            &#123;</div><div class="line">                Tmp = A[ j ];</div><div class="line">                A[ j ] = A[ j + <span class="number">1</span>];</div><div class="line">                A[ j + <span class="number">1</span>] = Tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h1><p>插入排序由N-1趟排序组成，并且利用了这样的事实：位置0到位置P-1上的元素是排过序的。  </p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  </p>
<h2 id="算法原理：-1"><a href="#算法原理：-1" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5  </li>
</ol>
<h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h2><ul>
<li>由于嵌套循环的每一个都花费N次迭代，因此插入排序为O(n²)，而且这个界是精确的，因为以反序输入同样可以达到该界。  </li>
<li>如果输入数据是有序的，那么运行时间为O(n)，因为内层的for循环的检测总是立即判定不成立而终止。  </li>
</ul>
<p>综上，插入排序的平均情形也是O(n²)。  </p>
<h2 id="算法稳定性：-1"><a href="#算法稳定性：-1" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。  </p>
<h2 id="算法实现：-1"><a href="#算法实现：-1" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> j, P;</div><div class="line"></div><div class="line">    ElemType Tmp;</div><div class="line">    <span class="keyword">for</span>( P = <span class="number">1</span>; P &lt; N; P++ )</div><div class="line">    &#123;</div><div class="line">        Tmp = A[ P ];</div><div class="line">        <span class="keyword">for</span>( j = P; j &gt; <span class="number">0</span> &amp;&amp; A[ j - <span class="number">1</span> ] &gt; Tmp; j-- )</div><div class="line">            A[ j ] = A[ j - <span class="number">1</span> ];</div><div class="line">        A[ j ] = Tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># 希尔排序：(Shell Sort)</div><div class="line">希尔排序是插入排序的一种更高效的改进版本，通过比较相距一定距离的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止，所以希尔排序有时也叫缩小增量排序。  </div><div class="line"></div><div class="line">增量是希尔排序的重要部分，只要最终增量为<span class="number">1</span>任何增量序列（*increment sequence*）都可以工作。算法最开始以一定的增量进行排序。然后会继续以一定增量进行排序，最终算法以增量为<span class="number">1</span>进行排序。当增量为<span class="number">1</span>时，算法变为插入排序，这就保证了数据一定会被排序。  </div><div class="line"></div><div class="line">## 算法原理：</div><div class="line">先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量`d2&lt;d1`重复上述的分组和排序，直至所取的增量`dt=<span class="number">1</span>(dt&lt;dt-l&lt;…&lt;d2&lt;d1)`，即所有记录放在同一组中进行直接插入排序为止。  </div><div class="line"></div><div class="line">增量的选择有很多，并且关乎算法的效率。增量序列的一种流行选择是使用Shell建议的序列，`d1 = [ N / <span class="number">2</span>]`和`d(t) = [ d(t<span class="number">-1</span>)/<span class="number">2</span> ]`。  </div><div class="line"></div><div class="line">已知的最好步长串行是由Sedgewick提出的 `(<span class="number">1</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">41</span>, <span class="number">109</span>,...)`，该串行的项来自 `<span class="number">9</span> * <span class="number">4</span>^i - <span class="number">9</span> * <span class="number">2</span>^i + <span class="number">1</span>` 和 `<span class="number">4</span>^i - <span class="number">3</span> * <span class="number">2</span>^i + <span class="number">1</span>` 这两个算式，这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。  </div><div class="line"></div><div class="line">## 算法分析：</div><div class="line">#### 优劣</div><div class="line"></div><div class="line">希尔排序是基于插入排序的一种算法，在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^<span class="number">3</span>/<span class="number">2</span>)，但是现今仍然没有人能找出希尔排序的精确下界。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n²)复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。   </div><div class="line"></div><div class="line">#### 时间性能</div><div class="line"></div><div class="line"><span class="number">1.</span> 增量序列的选择</div><div class="line">Shell排序的执行时间依赖于增量序列。</div><div class="line">好的增量序列的共同特征：</div><div class="line">- 最后一个增量必须为<span class="number">1</span>；</div><div class="line">- 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。</div><div class="line">有人通过大量的实验，给出了较好的结果：当n较大时，比较和移动的次数约在nl<span class="number">.25</span>到<span class="number">1.6</span>n1<span class="number">.25</span>之间。  </div><div class="line"></div><div class="line"><span class="number">2</span>． Shell排序的时间性能优于直接插入排序</div><div class="line">希尔排序的时间性能优于直接插入排序的原因：</div><div class="line">①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</div><div class="line">②当n值较小时，n和的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度<span class="number">0</span>()差别不大。</div><div class="line">③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di<span class="number">-1</span>作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。  </div><div class="line"></div><div class="line">因此，希尔排序在效率上较直接插入排序有较大的改进。  </div><div class="line"></div><div class="line">## 算法稳定性：</div><div class="line">由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。  </div><div class="line"></div><div class="line">## 算法实现：</div><div class="line">```C</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shellsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j, Increment;</div><div class="line">    ElemType Tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( Increment = N / <span class="number">2</span>; Increment &gt; <span class="number">0</span>; Increment /= <span class="number">2</span> )</div><div class="line">        <span class="keyword">for</span>( i = Increment; i &lt; N; i++ )</div><div class="line">        &#123;</div><div class="line">            Tmp = A[ i ];</div><div class="line">            <span class="keyword">for</span>( j = i; j &gt;= Increment; j -= Increment )</div><div class="line">                <span class="keyword">if</span>( Tmp &lt; A[ j - Increment ] )</div><div class="line">                    A[ j ] = A[ j - Increment];</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            A[ j ] = Tmp;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="选择排序-Selection-sort"><a href="#选择排序-Selection-sort" class="headerlink" title="选择排序(Selection sort)"></a>选择排序(Selection sort)</h1><p>选择排序(Selection sort)是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="算法原理：-2"><a href="#算法原理：-2" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>从未排序的数组中选择最小的元素，组成有序序列。</li>
<li>从无序序列中继续挑选最小的元素，插入有序序列。</li>
<li>以此类推，直到全部转化为有序序列。</li>
</ol>
<h2 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h2><p>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。  </p>
<p>比较次数O(n^2),比较次数与关键字的初始状态无关，总的比较次数<code>N=(n-1)+(n-2)+...+1=n*(n-1)/2</code>。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。  </p>
<h2 id="算法稳定性：-2"><a href="#算法稳定性：-2" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。  </p>
<h2 id="算法实现：-2"><a href="#算法实现：-2" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selectsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j, loc;</div><div class="line">    ElemType min, Tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++)</div><div class="line">    &#123;</div><div class="line">        min = A[ i ];</div><div class="line">        <span class="keyword">for</span>( j = i; j &lt; N; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>( A[ j ] &lt;= min )</div><div class="line">            &#123;</div><div class="line">                min = A[ j ];</div><div class="line">                loc = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Tmp = A[ i ];</div><div class="line">        A[ i ] = A[ loc ];</div><div class="line">        A[ loc ] = Tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  </p>
<h3 id="堆节点的访问"><a href="#堆节点的访问" class="headerlink" title="堆节点的访问"></a>堆节点的访问</h3><p>通常堆是通过一维数组来实现的。在起始数组为 0 的情形中：</p>
<ul>
<li>父节点i的左子节点在位置 (2*i+1);</li>
<li>父节点i的右子节点在位置 (2*i+2);</li>
<li>子节点i的父节点在位置 floor((i-1)/2);</li>
</ul>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p>在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<h2 id="算法原理：-3"><a href="#算法原理：-3" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>先将无序的数组建立成一个最大堆(即最大值位于根结点的完全二叉树)。</li>
<li>依次从最大堆中删除最大值，放入数组尾部，并将最大堆重新调整。直到全部删除为止。</li>
</ol>
<h2 id="算法分析：-3"><a href="#算法分析：-3" class="headerlink" title="算法分析："></a>算法分析：</h2><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用PercDown(下滤算法)实现的。  </p>
<p>平均性能 O(N*logN)。  </p>
<p>其他性能</p>
<ul>
<li>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。</li>
<li>堆排序是就地排序，辅助空间为O(1）.</li>
<li>在最坏的情况下，堆排序最多使用<code>2NlogN - O(N)</code>次比较。</li>
</ul>
<h2 id="算法稳定性：-3"><a href="#算法稳定性：-3" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>它是不稳定的排序方法。  </p>
<h2 id="算法实现：-3"><a href="#算法实现：-3" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LeftChild(i) (2*(i)+1)</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">( ElemType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> Child;</div><div class="line">    ElemType Tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( Tmp = A[ i ]; LeftChild( i ) &lt; N; i = Child )</div><div class="line">    &#123;</div><div class="line">        Child = LeftChild( i );</div><div class="line">        <span class="keyword">if</span>( Child != N - <span class="number">1</span> &amp;&amp; A[ Child + <span class="number">1</span> ] &gt; A[ Child ])</div><div class="line">            Child++;</div><div class="line">        <span class="keyword">if</span>( Tmp &lt; A[ Child ])</div><div class="line">            A[ i ] = A[ Child ];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    A[ i ] = Tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    ElemType Tmp;</div><div class="line">    <span class="keyword">for</span>( i = N / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- )</div><div class="line">        PercDown( A, i, N);</div><div class="line">    <span class="keyword">for</span>( i = N - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- )</div><div class="line">    &#123;</div><div class="line">        Tmp = A[ <span class="number">0</span> ];</div><div class="line">        A[ <span class="number">0</span> ] = A[ i ];</div><div class="line">        A[ i ] = Tmp;</div><div class="line">        PercDown( A, <span class="number">0</span>, i );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾基础的排序算法&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://thinknight.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Post Test</title>
    <link href="http://thinknight.github.io/2014/Hexo/post-test/"/>
    <id>http://thinknight.github.io/2014/Hexo/post-test/</id>
    <published>2014-02-22T03:40:20.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频&amp;音频测试<br><a id="more"></a></p>
<p>唉？插首歌听听看？  </p>
<embed src="http://www.xiami.com/widget/9658306_1769921558/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent">  

<!--more-->
<p>再来个视频！  </p>
<embed src="http://player.youku.com/player.php/sid/XNjY4NDc5MDc2/v.swf" allowfullscreen="true" quality="high" width="480" height="400" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">  

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视频&amp;amp;音频测试&lt;br&gt;
    
    </summary>
    
    
      <category term="Article" scheme="http://thinknight.github.io/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://thinknight.github.io/2014/Hexo/hello-world/"/>
    <id>http://thinknight.github.io/2014/Hexo/hello-world/</id>
    <published>2014-02-19T13:17:20.000Z</published>
    <updated>2017-06-27T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个用<a href="http://zespia.tw/hexo/" target="_blank" rel="external">hexo</a>搭建的博客。<br><a id="more"></a></p>
<p>hexo是基于<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a>的一个博客框架，由台湾的大学生<a href="https://github.com/tommy351/hexo/" target="_blank" rel="external">tommy351</a>所写……（人家都能写出框架了我还什么都不会&gt;_&lt;）。  </p>
<p>我在寒假之前就有了搭一个博客的想法，当时比较热血，想不用现成的框架从后台撸到前端一个人通通搞定。所以整个寒假都在宅在家，看了Python学了点<a href="https://docs.djangoproject.com/en/1.6/" target="_blank" rel="external">Django</a>，又了解了一点前端的知识。这么多东西看下来虽然不是很费劲，但是真正要开始动手做的时候才发现，继续学习的周期和搭建的时间实在太长，为了一个博客实在不值得，如果真要学这些知识，以后可以慢慢来，有针对性地去做，而不是妄图一口吃成个胖子，在什么都不懂的时候干一个Full Stack developer才能做的事。</p>
<blockquote>
<p>吾生也有涯，而知也无涯。以有涯随无涯，殆已。  </p>
</blockquote>
<p>知乎上有个题主说的很对：“不要试图使自己做个万能的人，去关注你最为关注的东西。” 虽然这个博客不是用Django搭建，但寒假的学习也让我了解了很多LAMP和web方面的东西，并没有白白浪费时间。  </p>
<p>当然了这些都不是重点，我搭这个博客也不是为了好玩打发时间，而是想把自己学习的东西记录下来，分享出去，也算是对自己的生活有个记录和交代。这个其实也是向<a href="http://teekee.org" target="_blank" rel="external">林文</a>学长和<a href="http://blog.weatherpark.info/" target="_blank" rel="external">张春荣</a>学长学习的，我曾经从他们身上学到和了解到了很多东西，他们也在继续影响着我，如果不是因为他们，我现在可能更渣。  </p>
<p>虽然已经大二了，但有些东西现在开始，也为时未晚罢。  </p>
<p>就是这样。  </p>
<hr>
<pre><code>choice = int(raw_input(&quot;&quot;&quot;If u like this blog, enter 1, else whatever.\n&quot;&quot;&quot;))

while choice != 1:
    choice = int(raw_input(&apos;Please?&gt;_&lt;\n&apos;))
else:
    print &apos;I like u!&apos;
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个用&lt;a href=&quot;http://zespia.tw/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;搭建的博客。&lt;br&gt;
    
    </summary>
    
    
      <category term="Article" scheme="http://thinknight.github.io/tags/Article/"/>
    
  </entry>
  
</feed>
