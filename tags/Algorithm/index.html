<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="I will survive"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Matrix Wall" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Algorithm - Matrix Wall</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><link rel="stylesheet" href="/css/prism.css" type="text/css"><script src="/js/prism.js"></script></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Matrix Wall</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-03-24T09:54:45.000Z" class="post__time">March 24, 2014</time><h1 class="post__title"><a href="/2014/Algorithm/divide-and-conquer/">简单分治</a></h1></header><div class="post__main echo"><p>在之前的排序算法中，我们提到了一种叫归并排序的算法，就是通过把待排序的数列分成一个个小的数列并排序成有序表，再将这些小的有序表组合成一个新的有序表来完成排序，所以归并排序算法就是利用分治策略的一个很好的典型。<br><a id="more"></a></p>
<h1 id="概念阐述"><a href="#概念阐述" class="headerlink" title="概念阐述"></a>概念阐述</h1><p>在分治策略中我们用递归的方法来求解一个问题，在每一层的递归中应用如下的三个步骤：</p>
<ul>
<li>分解(Dived)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li>解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并(Combine)步骤将子问题的解组合成原问题的解。  </li>
</ul>
<p>简单通俗地来说，所谓的<strong>分治策略</strong>就是把很复杂的问题用递归的方式细化成一个个小的，能够解决子问题，再把所有子问题的解合并起来，就得到原问题的解。  </p>
<p>下面就通过一个例子来简单介绍分治策略。  </p>
<h1 id="实例问题"><a href="#实例问题" class="headerlink" title="实例问题"></a>实例问题</h1><p>这里有一个数组A：</p>
<blockquote>
<p><code>[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</code>  </p>
</blockquote>
<p>现在要求寻找数组A中和最大的非空连续子数组（我们称这样的连续子数组为<strong>最大子数组</strong>）。</p>
<h2 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h2><p>乍一看到这个问题，首先想到的当然就是简单粗暴地套上双重循环，尝试每对可能的组合，再进行比较，得出最终结果，这就是我们常说的暴力求解法，算法实现如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大子数组问题：暴力求解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>,     <span class="number">22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>( A ) / <span class="keyword">sizeof</span>( <span class="keyword">int</span> );</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, sum, step, left;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt;= length; i++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; ( j + i <span class="number">-1</span> ) &lt;= length<span class="number">-1</span>; j++ )  </span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( k = j; k &lt;= j + i - <span class="number">1</span>; k++ ) </span><br><span class="line">                sum += A[ k ];</span><br><span class="line">            <span class="keyword">if</span>( sum &gt; max )</span><br><span class="line">            &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                left = j;</span><br><span class="line">                step = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"length:%d, max:%d, left:%d, right:%d, step:%d\n"</span>, length, max, left, left+step<span class="number">-1</span>, step);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">但是套上两个循环后，算法的时间复杂度就变为了O(n²)，我们还有更好的方法。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 分治策略求解法</span><br><span class="line"></span><br><span class="line">现在我们假设要寻找子数组`A[low..high]`的最大子数组，使用分治就意味着要把数组A分成两个规模尽量相等的子数组，也就是说找到数组的中央位置mid，然后考虑求解两个子数组`A[low..mid]`和`A[mid+<span class="number">1.</span>.high]`。这时的最大子数组`A[i..j]`所在的位置必然是如下三处：</span><br><span class="line">- 完全处于子数组`A[low..mid]`中，因此 `low ≤ i ≤ j ≤ mid`。</span><br><span class="line">- 完全处于子数组`A[mid+<span class="number">1.</span>.high]`中，因此 `mid+<span class="number">1</span> ≤ i ≤ j ≤ high`。</span><br><span class="line">- 跨越了中点mid，因此 `low≤ i ≤ mid &lt; j ≤ high`。  </span><br><span class="line"></span><br><span class="line">接下来我们就可以递归地求解数组`A[low..mid]`和`A[mid+<span class="number">1.</span>.high]`的最大子数组，因为这两个子问题仍然是最大子数组问题，只是规模更小，因此剩下的子工作就是在这三个子数组的最大子数组中找出最大的一个。</span><br><span class="line"></span><br><span class="line">任何跨中点的最大子数组都由两个子数组`A[i..mid]`和`A[mid+<span class="number">1.</span>.j]`组成，其中low≤ i ≤ mid且mid &lt; j ≤ high，因此只要找到形如`A[i..mid]`和`A[mid+<span class="number">1.</span>.j]`的最大子数组，然后将其合并即可，对此算导给出了如下的伪代码：</span><br></pre></td></tr></table></figure>
<p>FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high )<br>    left-sum = -100000<br>    sum = 0<br>    for i = mid downto low<br>        sum = sum + A[i]<br>        if sum &gt; left-sum<br>            left-sum = sum<br>            max-left = i</p>
<pre><code>right-sum = -100000
sum = 0
for j = mid + 1 to high
    sum = sum + A[i]
    if sum &gt; right-sum
        right-sum = sum
        max-right = j

return (max-left, max-right, left-sum + right-sum)
</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">有了线性时间的FIND-MAX-CROSSING-SUBARRRY，我们就可以设计求解最大子数组问题的分治算法的伪代码：</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>FIND-MAXIMUM-SUBARRAY(A, low, high)<br>if high == low<br>    return ( low, high, A[low] );<br>else<br>    mid = ( low + high ) / 2<br>    ( left-low, left-high, left-sum ) =<br>        FIND-MAXIMUM-SUBARRAY( A, low, mid )<br>    ( right-low, right-high, right-sum ) =<br>        FIND-MAXIMUM-SUBARRAY( A, mid + 1, high )<br>    ( cross-low, cross-high, cross-sum ) =<br>        FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high )<br>    if left-sum &gt;= right-sum and left-sum &gt;= cross-sum<br>        return ( left-low, left-high, left-sum )<br>    elseif right-sum &gt;= left-sum and right-sum &gt;= cross-sum<br>        return ( right-low, right-high, right-sum )<br>    else<br>        return ( cross-low, cross-high, cross-sum )<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">具体实现代码如下：</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p>//最大子数组问题：分治策略法</p>
<p>#include &lt;stdio.h&gt;<br>int last_low, last_high;</p>
<p>int<br>find_max_cro_arr( int A[], int low, int mid, int high )<br>{<br>    int i, j;<br>    int left_sum = -100000;<br>    int sum = 0;<br>    for( i = mid; i &gt;= low; i– ){<br>        sum += A[ i ];<br>        if( sum &gt; left_sum )<br>        {<br>            left_sum = sum;<br>            last_low = i;<br>        }<br>    }</p>
<pre><code>int right_sum = -100000;
sum = 0;
for( j = mid + 1; j &lt;= high; j++ ){
    sum = sum + A[ j ];
    if( sum &gt; right_sum )
    {
        right_sum = sum;
        last_high = j;
    }    
}
return left_sum + right_sum;
</code></pre><p>}</p>
<p>int<br>find_max_arr( int A[], int low, int high )<br>{<br>    int left_sum, right_sum, cross_sum;<br>    if( high == low )<br>        return A[ low ];<br>    else<br>    {<br>        int mid = ( low + high ) / 2;<br>        left_sum = find_max_arr( A, low, mid );<br>        right_sum = find_max_arr( A, mid + 1, high );<br>        cross_sum = find_max_cro_arr( A, low, mid, high );<br>        if ( left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum )<br>            return left_sum;<br>        else if ( right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum )<br>                return right_sum;<br>            else<br>                return cross_sum;    </p>
<pre><code>}
</code></pre><p>}</p>
<p>int<br>main()<br>{<br>    int A[] = { 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 };<br>    int length = sizeof( A ) / sizeof( int );<br>    int sum = find_max_arr( A, 0, length - 1 );<br>    printf(“max_sum:%d, low:%d, high:%d\n”, sum, last_low, last_high);</p>
<pre><code>getchar();
return 0;
</code></pre><p>}<br><code>`</code>  </p>
<p>参考资料：《算法导论：第三版》。</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Algorithm/" class="post__tag__link">Algorithm</a></li></ul><a href="/2014/Algorithm/divide-and-conquer/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2014-03-04T14:20:39.000Z" class="post__time">March 4, 2014</time><h1 class="post__title"><a href="/2014/Algorithm/sort2/">排序算法（二）</a></h1></header><div class="post__main echo"><p>上一篇介绍了几种简单的排序算法，这一篇来谈谈<strong>归并排序</strong>和<strong>快速排序</strong>。<br><a id="more"></a></p>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>顾名思义，归并算法就是将两个或两个以上的有序表组合成一个新的有序表，所以归并排序算法是递归算法的一个很好的实例。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>归并操作的过程如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾  </li>
</ol>
<p>举个例子吧:  </p>
<blockquote>
<p><code>[ 10 4 6 3 8 2 5 7 ]</code><br><code>[ 10 4 6 3 ]   [ 8 2 5 7 ]</code><br><code>[ 10 4 ]  [ 6 3 ]  [ 8 2 ]  [ 5 7 ]</code><br><del><code>[ 10 ] [ 4 ] [ 6 ] [ 3 ] [ 8 ] [ 2 ] [ 5 ] [ 7 ]</code></del><br><code>[ 4 10 ]  [ 3 6  ] [ 2 8 ]  [ 5 7 ]</code><br><code>[ 3 4 6 10 ]  [ 2 5 7 8 ]</code><br><code>[ 2 3 4 5 6 7 8 10 ]</code>  </p>
</blockquote>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul>
<li><p>最差时间复杂度：O(nlogn)  </p>
</li>
<li><p>最优时间复杂度：O(n)  </p>
</li>
<li><p>平均时间复杂度：O(nlogn)  </p>
</li>
</ul>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>归并排序是一种稳定的排序方法  </p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><pre class=" language-C"><span class="comment"><code class="language-C"><span class="comment">//归并排序</span>
<span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;

<span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Lpos, <span class="keyword">int</span> Rpos, <span class="keyword">int</span> RightEnd )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">Mergesort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>;

<span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Lpos, <span class="keyword">int</span> Rpos, <span class="keyword">int</span> RightEnd )</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> i, LeftEnd, NumElements, TmpPos;
    LeftEnd = Rpos - <span class="number">1</span>;
    TmpPos = Lpos;
    NumElements = RightEnd - Lpos + <span class="number">1</span>;

    <span class="keyword">while</span>( Lpos <= leftend="" &&="" rpos="" <="RightEnd" )="" <span="" class="keyword">if</=></code></span>( A[ Lpos ] <= a[="" rpos="" ]="" )="" tmparray[="" tmppos++="" lpos++="" ];="" <span="" class="keyword">else
            TmpArray[ TmpPos++ ] = A[ Rpos++ ];

    <span class="keyword">while</span>( Lpos <= leftend="" )="" tmparray[="" tmppos++="" ]="A[" lpos++="" ];="" <span="" class="keyword">while( Rpos <= rightend="" )="" tmparray[="" tmppos++="" ]="A[" rpos++="" ];="" <span="" class="keyword">for( i = <span class="number">0</span>; i < NumElements; i++, RightEnd-- )
        A[ RightEnd ] = TmpArray[ RightEnd ];
}

<span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">( ElemType A[], ElemType TmpArray[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> Center;

    <span class="keyword">if</span>( Left < Right )
    {
        Center = ( Left + Right ) / <span class="number">2</span>;
        MSort( A, TmpArray, Left, Center );
        MSort( A, TmpArray, Center + <span class="number">1</span>, Right );
        Merge( A, TmpArray, Left, Center + <span class="number">1</span>, Right );
    }
}

<span class="function"><span class="keyword">void</span> <span class="title">Mergesort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>
<span class="function"></span>{
    ElemType *TmpArray;

    TmpArray = <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( ElemType ));
    <span class="keyword">if</span>( TmpArray != <span class="literal">NULL</span>)
    {
        MSort( A, TmpArray, <span class="number">0</span>, N - <span class="number">1</span> );
        <span class="built_in">free</span>( TmpArray );
    }
    <span class="keyword">else</span>
        <span class="built_in">printf</span>(<span class="string">"No space for tmp array!!!"</span>);
}
</=></=></=></pre>
<p>虽然归并排序的运行时间是O（nlogn），但是它很难用于主存排序，主要问题在于合并两个排序的表需要线性附加内存，在整个算法中还要花费将数据拷贝到临时数组再拷贝回来这样一些附加的工作，其结果严重放慢了排序的速度。</p>
<p>归并排序不仅可以用分治的策略来递归处理，也可以用迭代的方法来表示，但即使这样，对于重要的内部排序而言，人们还是选择快速排序。  </p>
<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>正如它的名字所标示的，快速排序是在实践中已知的最快排序算法，该算法特别快，主要是由于非常精炼和高度优化的内部循环。像归并排序一样，快速排序也是一种分治的递归算法。  </p>
<h2 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h2><p>将数组S排序的基本算法由下列简单的4步组成：</p>
<ol>
<li>如果S中元素个数是0或1，则返回。</li>
<li>取S中任一元素，称之为枢纽元。</li>
<li>将A = S - {v}(S中其余元素)分成两个不相交的集合：S1 = { x属于A | x &lt;= v } 和S2= { x属于A | x &gt;= v }。</li>
<li>返回{quicksort(S1)后，继随v,继而quicksort(S2)}.</li>
</ol>
<p>下面给出一个乱序的数组<code>{[ 50 10 90 30 70 40 80 60 20 }</code>，以第一个元素<code>50</code>为枢纽元，来展现快速排序的过程。</p>
<blockquote>
<p><code>[ (50) 10 90 30 70 40 80 60 (20) ]</code> 第1次交换  </p>
</blockquote>
<blockquote>
<p><code>[ (20) 10 90 30 70 40 80 60 (50) ]</code> 第2次交换  </p>
</blockquote>
<blockquote>
<p><code>[ 20 10 (50) 30 70 40 80 60 (90) ]</code> 第3次交换  </p>
</blockquote>
<blockquote>
<p><code>[ 20 10 (40) 30 70 (50) 80 60 90 ]</code> 第4次交换  </p>
</blockquote>
<blockquote>
<p><code>[ 20 10 40 30 (50) (70) 80 60 90 ]</code> 第5次交换  </p>
</blockquote>
<blockquote>
<p><code>[ 20 10 40 30 （50）70 80 60 90 ]</code>  第6次交换  </p>
</blockquote>
<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><ul>
<li>最差时间复杂度：O(n²)</li>
<li>最优时间复杂度：O(nlogn)</li>
<li>平均时间复杂度：O(nlogn)  </li>
</ul>
<h2 id="算法稳定性-1"><a href="#算法稳定性-1" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>快速排序是一种稳定的排序方法  </p>
<h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><pre class=" language-C"><span class="keyword">typedef</span> <span class="keyword"><code class="language-C"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;

<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>;

<span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span>
<span class="function"></span>{
    QSort( A, <span class="number">0</span>, N - <span class="number">1</span> );
}

<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> Tmp;
    Tmp = A[ a ];
    A[ a ] = A[ b ];
    A[b] = Tmp;
}

<span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> pivot;

    <span class="keyword">if</span>( low < high )
    {
        pivot = Partition( A, low, high );
        QSort( A, low, pivot<span class="number">-1</span> );
        QSort( A, pivot+<span class="number">1</span>, high );
    }
}

<span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> pivotkey;
    pivotkey = A[ low ];
    <span class="keyword">while</span>( low < high )
    {
        <span class="keyword">while</span>( low < high && A[ high ] >= pivotkey )
            high--;
        swap(A, low, high);
        <span class="keyword">while</span>( low < high && A[ low ] <= pivotkey)="" low++;="" swap(a,="" low,="" high);="" }="" <span="" class="keyword">return</=></code></span> low;
}

</pre>
<hr>
<p>排序算法的内容就差不多先写到这里了，其实学习算法，光能用代码写出算法和理解原理只是初步的学习，最近看了《算法导论》才认识到，一个算法不光光只像这两篇文章里写的内容那么简单，还包含各自复杂的数学证明和进一步的优化，我的学习还有待继续深入！  </p>
<h1 id="舞动的排序算法"><a href="#舞动的排序算法" class="headerlink" title="舞动的排序算法"></a>舞动的排序算法</h1><p>如果光看文字还理解不了算法原理的话，这里有一组用舞蹈的形式来展现排序算法的原理的视频。  </p>
<ul>
<li><a href="http://v.youku.com/v_show/id_XMzMyOTAyMzQ0.html?f=16755664" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5Njg4.html?f=16755664" target="_blank" rel="noopener">归并排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5MzI4.html?f=16755664" target="_blank" rel="noopener">希尔排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk5MDI0.html?f=16755664" target="_blank" rel="noopener">选择排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk4NTQ4.html?f=16755664" target="_blank" rel="noopener">快速排序</a></li>
<li><a href="http://v.youku.com/v_show/id_XMzMyODk3NjI4.html?f=16755664" target="_blank" rel="noopener">插入排序</a></li>
</ul>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Algorithm/" class="post__tag__link">Algorithm</a></li></ul><a href="/2014/Algorithm/sort2/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2014-03-02T13:27:12.000Z" class="post__time">March 2, 2014</time><h1 class="post__title"><a href="/2014/Algorithm/sort/">排序算法（一）</a></h1></header><div class="post__main echo"><p>回顾基础的排序算法<br><a id="more"></a></p>
<p>在数据结构这门课程里，学校的老师们是较侧重于教学生如何利用诸如C语言来实现线性表，队列，栈，树这些简单的数据结构，理解这些数据结构的用法，而往往轻视了后半块关于图论，排序，查找等偏算法分析方面的内容的教学。  </p>
<p>虽然课程的名字叫做数据结构，但很多CS强校和国外的著作都习惯地把它称作“数据结构与算法分析”。说到底，数据结构只能算是对编程语言使用的一个延伸，很多程序设计入门书诸如《C Primer Plus》和《C和指针》的后半段都会谈一些链表，树等内容，所以现在回过头来看，前面数据结构的学习还是为了在后面实现一些复杂的算法的时候，能够更好地利用这些结构来处理数据和实现算法中的思想。  </p>
<p>在期末考试中，我们最后的大题目往往都是解答题，要求学生用编程语言实现诸如快速排序这样的算法，那么这样来看的话，独立实现这些复杂的算法，便就是真正考验这门课程是否学好的重要标准之一。  </p>
<p>这一篇就先回顾<strong>排序算法</strong>。  </p>
<hr>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种比较简单的排序算法，通常被用来对于刚入门学习程序设计的学生介绍算法的概念。  </p>
<h2 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><ul>
<li><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数(n-1)和记录移动次数(0)均达到最小值。<br>所以，冒泡排序最好的时间复杂度为O(n)。 </p>
</li>
<li><p>若初始文件是反序的，需要进行趟排序。每趟排序要进行次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：O(n²)</p>
</li>
<li><p>冒泡排序的最坏时间复杂度为O(n²)。  </p>
</li>
</ul>
<p>综上，因此冒泡排序总的平均时间复杂度为O(n²)。</p>
<h2 id="算法稳定性："><a href="#算法稳定性：" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>由于冒泡算法的核心思想就是把小的元素往前调，大的元素往后调，相同的元素不做处理，所以即使相同的元素中间还隔着其他元素，这两个元素也不会发生交换，所以冒泡排序是一种稳定的排序算法。  </p>
<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ElemType Tmp;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[ j ] &gt; A[ j + <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                Tmp = A[ j ];</span><br><span class="line">                A[ j ] = A[ j + <span class="number">1</span>];</span><br><span class="line">                A[ j + <span class="number">1</span>] = Tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h1><p>插入排序由N-1趟排序组成，并且利用了这样的事实：位置0到位置P-1上的元素是排过序的。  </p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  </p>
<h2 id="算法原理：-1"><a href="#算法原理：-1" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5  </li>
</ol>
<h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h2><ul>
<li>由于嵌套循环的每一个都花费N次迭代，因此插入排序为O(n²)，而且这个界是精确的，因为以反序输入同样可以达到该界。  </li>
<li>如果输入数据是有序的，那么运行时间为O(n)，因为内层的for循环的检测总是立即判定不成立而终止。  </li>
</ul>
<p>综上，插入排序的平均情形也是O(n²)。  </p>
<h2 id="算法稳定性：-1"><a href="#算法稳定性：-1" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。  </p>
<h2 id="算法实现：-1"><a href="#算法实现：-1" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, P;</span><br><span class="line"></span><br><span class="line">    ElemType Tmp;</span><br><span class="line">    <span class="keyword">for</span>( P = <span class="number">1</span>; P &lt; N; P++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = A[ P ];</span><br><span class="line">        <span class="keyword">for</span>( j = P; j &gt; <span class="number">0</span> &amp;&amp; A[ j - <span class="number">1</span> ] &gt; Tmp; j-- )</span><br><span class="line">            A[ j ] = A[ j - <span class="number">1</span> ];</span><br><span class="line">        A[ j ] = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 希尔排序：(Shell Sort)</span><br><span class="line">希尔排序是插入排序的一种更高效的改进版本，通过比较相距一定距离的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止，所以希尔排序有时也叫缩小增量排序。  </span><br><span class="line"></span><br><span class="line">增量是希尔排序的重要部分，只要最终增量为<span class="number">1</span>任何增量序列（*increment sequence*）都可以工作。算法最开始以一定的增量进行排序。然后会继续以一定增量进行排序，最终算法以增量为<span class="number">1</span>进行排序。当增量为<span class="number">1</span>时，算法变为插入排序，这就保证了数据一定会被排序。  </span><br><span class="line"></span><br><span class="line">## 算法原理：</span><br><span class="line">先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量`d2&lt;d1`重复上述的分组和排序，直至所取的增量`dt=<span class="number">1</span>(dt&lt;dt-l&lt;…&lt;d2&lt;d1)`，即所有记录放在同一组中进行直接插入排序为止。  </span><br><span class="line"></span><br><span class="line">增量的选择有很多，并且关乎算法的效率。增量序列的一种流行选择是使用Shell建议的序列，`d1 = [ N / <span class="number">2</span>]`和`d(t) = [ d(t<span class="number">-1</span>)/<span class="number">2</span> ]`。  </span><br><span class="line"></span><br><span class="line">已知的最好步长串行是由Sedgewick提出的 `(<span class="number">1</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">41</span>, <span class="number">109</span>,...)`，该串行的项来自 `<span class="number">9</span> * <span class="number">4</span>^i - <span class="number">9</span> * <span class="number">2</span>^i + <span class="number">1</span>` 和 `<span class="number">4</span>^i - <span class="number">3</span> * <span class="number">2</span>^i + <span class="number">1</span>` 这两个算式，这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。  </span><br><span class="line"></span><br><span class="line">## 算法分析：</span><br><span class="line">#### 优劣</span><br><span class="line"></span><br><span class="line">希尔排序是基于插入排序的一种算法，在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^<span class="number">3</span>/<span class="number">2</span>)，但是现今仍然没有人能找出希尔排序的精确下界。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n²)复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。   </span><br><span class="line"></span><br><span class="line">#### 时间性能</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 增量序列的选择</span><br><span class="line">Shell排序的执行时间依赖于增量序列。</span><br><span class="line">好的增量序列的共同特征：</span><br><span class="line">- 最后一个增量必须为<span class="number">1</span>；</span><br><span class="line">- 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。</span><br><span class="line">有人通过大量的实验，给出了较好的结果：当n较大时，比较和移动的次数约在nl<span class="number">.25</span>到<span class="number">1.6</span>n1<span class="number">.25</span>之间。  </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>． Shell排序的时间性能优于直接插入排序</span><br><span class="line">希尔排序的时间性能优于直接插入排序的原因：</span><br><span class="line">①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</span><br><span class="line">②当n值较小时，n和的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度<span class="number">0</span>()差别不大。</span><br><span class="line">③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di<span class="number">-1</span>作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。  </span><br><span class="line"></span><br><span class="line">因此，希尔排序在效率上较直接插入排序有较大的改进。  </span><br><span class="line"></span><br><span class="line">## 算法稳定性：</span><br><span class="line">由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。  </span><br><span class="line"></span><br><span class="line">## 算法实现：</span><br><span class="line">```C</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shellsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, Increment;</span><br><span class="line">    ElemType Tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( Increment = N / <span class="number">2</span>; Increment &gt; <span class="number">0</span>; Increment /= <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">for</span>( i = Increment; i &lt; N; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Tmp = A[ i ];</span><br><span class="line">            <span class="keyword">for</span>( j = i; j &gt;= Increment; j -= Increment )</span><br><span class="line">                <span class="keyword">if</span>( Tmp &lt; A[ j - Increment ] )</span><br><span class="line">                    A[ j ] = A[ j - Increment];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            A[ j ] = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="选择排序-Selection-sort"><a href="#选择排序-Selection-sort" class="headerlink" title="选择排序(Selection sort)"></a>选择排序(Selection sort)</h1><p>选择排序(Selection sort)是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="算法原理：-2"><a href="#算法原理：-2" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>从未排序的数组中选择最小的元素，组成有序序列。</li>
<li>从无序序列中继续挑选最小的元素，插入有序序列。</li>
<li>以此类推，直到全部转化为有序序列。</li>
</ol>
<h2 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h2><p>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。  </p>
<p>比较次数O(n^2),比较次数与关键字的初始状态无关，总的比较次数<code>N=(n-1)+(n-2)+...+1=n*(n-1)/2</code>。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。  </p>
<h2 id="算法稳定性：-2"><a href="#算法稳定性：-2" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。  </p>
<h2 id="算法实现：-2"><a href="#算法实现：-2" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selectsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, loc;</span><br><span class="line">    ElemType min, Tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = A[ i ];</span><br><span class="line">        <span class="keyword">for</span>( j = i; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[ j ] &lt;= min )</span><br><span class="line">            &#123;</span><br><span class="line">                min = A[ j ];</span><br><span class="line">                loc = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Tmp = A[ i ];</span><br><span class="line">        A[ i ] = A[ loc ];</span><br><span class="line">        A[ loc ] = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  </p>
<h3 id="堆节点的访问"><a href="#堆节点的访问" class="headerlink" title="堆节点的访问"></a>堆节点的访问</h3><p>通常堆是通过一维数组来实现的。在起始数组为 0 的情形中：</p>
<ul>
<li>父节点i的左子节点在位置 (2*i+1);</li>
<li>父节点i的右子节点在位置 (2*i+2);</li>
<li>子节点i的父节点在位置 floor((i-1)/2);</li>
</ul>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p>在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<h2 id="算法原理：-3"><a href="#算法原理：-3" class="headerlink" title="算法原理："></a>算法原理：</h2><ol>
<li>先将无序的数组建立成一个最大堆(即最大值位于根结点的完全二叉树)。</li>
<li>依次从最大堆中删除最大值，放入数组尾部，并将最大堆重新调整。直到全部删除为止。</li>
</ol>
<h2 id="算法分析：-3"><a href="#算法分析：-3" class="headerlink" title="算法分析："></a>算法分析：</h2><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用PercDown(下滤算法)实现的。  </p>
<p>平均性能 O(N*logN)。  </p>
<p>其他性能</p>
<ul>
<li>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。</li>
<li>堆排序是就地排序，辅助空间为O(1）.</li>
<li>在最坏的情况下，堆排序最多使用<code>2NlogN - O(N)</code>次比较。</li>
</ul>
<h2 id="算法稳定性：-3"><a href="#算法稳定性：-3" class="headerlink" title="算法稳定性："></a>算法稳定性：</h2><p>它是不稳定的排序方法。  </p>
<h2 id="算法实现：-3"><a href="#算法实现：-3" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LeftChild(i) (2*(i)+1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">( ElemType A[], <span class="keyword">int</span> i, <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Child;</span><br><span class="line">    ElemType Tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( Tmp = A[ i ]; LeftChild( i ) &lt; N; i = Child )</span><br><span class="line">    &#123;</span><br><span class="line">        Child = LeftChild( i );</span><br><span class="line">        <span class="keyword">if</span>( Child != N - <span class="number">1</span> &amp;&amp; A[ Child + <span class="number">1</span> ] &gt; A[ Child ])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>( Tmp &lt; A[ Child ])</span><br><span class="line">            A[ i ] = A[ Child ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[ i ] = Tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapsort</span><span class="params">( ElemType A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ElemType Tmp;</span><br><span class="line">    <span class="keyword">for</span>( i = N / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">        PercDown( A, i, N);</span><br><span class="line">    <span class="keyword">for</span>( i = N - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = A[ <span class="number">0</span> ];</span><br><span class="line">        A[ <span class="number">0</span> ] = A[ i ];</span><br><span class="line">        A[ i ] = Tmp;</span><br><span class="line">        PercDown( A, <span class="number">0</span>, i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/Algorithm/" class="post__tag__link">Algorithm</a></li></ul><a href="/2014/Algorithm/sort/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2019 thinKnight</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","matrixwall","count");
</script></body></html>