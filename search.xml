<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EJS 入门简介]]></title>
    <url>%2F2017%2FFont-End%2Fejs%2F</url>
    <content type="text"><![CDATA[EJS（Embedded JavaScript）是一种客户端的模板语言，通过把数据和模板结合起来去生成 HTML，下面给出一个简单介绍 EJS 的实例。 DEMO1. 原始 JSON 数据1234&#123; title: 'The Games List', game: ['GTA5', 'Titan Fall', 'Zelda'] &#125; 2. 模板对于 EJS ，在 &lt;% %&gt;之间的 JavaScript 会被执行，而&lt;%= 和 %&gt;之间的 JavaScript 会把 HTML 添加到生成的结果中。 123456&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&lt;ul&gt;&lt;% for(var i = 0; i &lt; supplies.length; i++) &#123;%&gt; &lt;li&gt;&lt;%= supplies[i] %&gt;&lt;/li&gt;&lt;% &#125; %&gt;&lt;/ul&gt; 3. 结果123456&lt;h1&gt;The Games List&lt;/li&gt;&lt;ul&gt; &lt;li&gt;GTA5&lt;/li&gt; &lt;li&gt;Titan Fall&lt;/li&gt; &lt;li&gt;Zelda&lt;/li&gt;&lt;/ul&gt; 上面是 &lt; 模板 + 数据 &gt; 后生成的 HTML 代码，在浏览器中显示的结果就是： The Games List GTA5 Titan Fall Zelda 以上是 EJS 的入门 DEMO， 下面阐述一下如何更深入地使用 EJS。 EJS 简单教程1. 引入 EJS我们的页面需要引入 EJS，这样 JavaScript 才能使用它，所以需要先下载 ejs_production.js，然后在 HTML 中插入 EJS： 1&lt;script type="text/javascript" src="ejs_production.js"&gt;&lt;/script&gt; 2. 创建一个模板要想将代码变得更简洁，第一步就是将 HTML 从 JavaScript 中分离开来。所以就需要把 HTML 抽离出来，放进单独的模板文件中。现在先创建个文件，命名为 cleaning.ejs，并插入以下代码： 12345678910&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&lt;ul&gt; &lt;% for(var i=0; i &lt; supplies.length; i++) &#123; %&gt; &lt;li&gt; &lt;a href='supplies/&lt;%= supplies[i] %&gt;'&gt; &lt;%= supplies[i] %&gt; &lt;/a&gt; &lt;li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; 你会注意到在&lt;% %&gt;两个标签里的代码都会被执行，并且&lt;%= %&gt;两标签之间的代码都将自己插入了被返回的 HTML 中。 我们需要添加 JavaScript 脚本来控制模板的加载和渲染，且将原始的涉及到字符串的代码用以下代码代替： 12// load the template file, then render it with datavar html = new EJS(&#123;url: 'cleaning.js'&#125;).render(data); 现在，模板代码将 HTML 存储在其准备好的结构中，使得 JavaScript 代码变得短小精悍。 3. 视图助手 - View HelperEJS 是使用 view helpers 来打包。view helper 是常用的视图代码的快捷方式，像链接和表单，使试图代码保持简单短小。 我们模板里的链接由类似于字符串的形式来构建： 12345&lt;li&gt; &lt;a href='supplies/&lt;%= supplies[i] %&gt;'&gt; &lt;%= supplies[i] %&gt; &lt;/a&gt;&lt;/li&gt; 上面的这段代码还是有点混乱，尤其是那么多嵌套的标签实在让人头昏眼花，所以接下来就可以用视图助手让代码变得轻量。 123&lt;li&gt; &lt;%= link_to(supplies[i], 'supplies/'+supplies[i]) %&gt; &lt;/li&gt; 现在代码就更简单明了了，还记不记得构建的链接是什么样的？ 12html += "&lt;li&gt;&lt;a href='supplies/"+data.supplies[i]+"&gt;"html += data.supplies[i]+"&lt;/a&gt;&lt;/li&gt; 于之前的 JavaScript 代码进行比对，不了解你所写代码的人也能很快地理解上面的 EJS 模板片段。 4. 错误处理如果在你写的 EJS 模板中有错误，EJS 将指出错误发生的确切行号，只要将 ejs_jslint.js 引入项目中。当然，这些错误可以使用 Chrome 的调试器查看。 5. 何时使用 EJS 来整理代码？ 用 JavaScript 来构建 HTML 使用 AJAX 的 web 服务 可换肤的应用 参考文档 官方网站 EJS 文档]]></content>
      <tags>
        <tag>font-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim使用笔记]]></title>
    <url>%2F2015%2FTool%2Fvim%2F</url>
    <content type="text"><![CDATA[我的Vim常用命令 基本操作移动光标 hjkl → （←↓↑→） 输入模式 i → 插入模式 a → 在光标后插入 r → 替换当前字符 删除 x → 删除光标下的字符 dd → 删除（并复制）当前行 ndd → 删除接下来 n 行 复制粘贴 yy → 复制当前行 nyy → 复制接下来 n 行 p → 粘贴 其他功能 Ctrl-r → 重做 u → 撤销 . → （小数点）重复上一次命令 Ctrl-p → 自动提示（或 Ctrl-n ） /pattern → 搜索 pattern 的字符串 % → 匹配括号移动，包括 [, (, {. *(resp. #) → 移动到下一个（resp. 上一个）当前光标下匹配的单词 行间操作跨行操作 o → 小写字母o，在当前行之后插入一行，并进入输入模式 O → 大写字母O，在当前行之前插入一行，并进入输入模式 gg → 到第一行 G → 到最后一行 NG → 到第N行（等同于 :N ，但是要按回车所以还是NG快点~） 当前行上移动光标 0 → 数字0，到行头 g_ → 到行尾 ^ → 到本行第一个不是 blank 字符的位置 $ → 到本行最后一个不是 blank 字符的位置 fa → 到下一个为字母 a 的匹配项处， ,（resp. ;） 会移动到下一个（resp. 上一个） t, → 到字符 , 之前 dt&quot; → 删除”之前的所有内容 块操作多行注释 ^ → 到行头 Ctrl-v → 开始块操作 j → 向下移动 I-- [ESC] → I是插入，插入--（或者 //,# 等注释符），按ESC键来为每一行生效 文件操作 :wq → 保存并退出 :e &lt;path/to/file&gt;→ 打开 :E → 浏览目录 :w → 保存 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :q! → 强制退出不保存 分屏分屏启动 使用大写的O参数来垂直分屏。 vim -On file1 file2 ... 使用小写的o参数来水平分屏。 vim -on file1 file2 ... 关闭分屏 Ctrl-w q → 关闭当前窗口，如果只剩最后一个则退出Vim Ctrl-w c → 关闭当前窗口 分屏操作 上下分割当前打开的文件。 Ctrl+W s 上下分割，并打开一个新的文件。 :sp filename 左右分割当前打开的文件。 Ctrl+W v 左右分割，并打开一个新的文件。 :vsp filename 移动光标Ctrl-w 后hjkl 写在后面 之前断断续续用过一段时间 Vim，但都因为工作量不算太多，而且一直在 Windows 下所以就改用了 Sublime Text, 但是最近才把 Vim 重新捡起来才发现真的好用，并且也吧 ST 开启了 Vim 模式，很是方便。 但 Emacs 什么的就算了吧。 参考资料 点我]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫（二）]]></title>
    <url>%2F2014%2FPython%2Fpython-crawler-2%2F</url>
    <content type="text"><![CDATA[上次写到了遍历网站的全部页面和向百度提交搜索，但是其中还存在着许多的问题。 解析HTML在上次的方法中，由于以前都是用简单的正则表达式来解析HTML，所以为了尝鲜我就使用了BeautifulSoup和SGMLParser两种方法。但是经过使用下来发现还是BeautifulSoup好那么一点，而且官方的文档也很详实，以后用起来也会更加方便。 当然了，这两者在解析的过程中都有自己的局限性，所以还得配合正则表达式使用。 循环与递归由于上次处理的只是遍历一个页面的URL，所以总的来说工作量比较小，然后我就用了递归这种最笨的方法。 但是显而易见，递归是一个非常耗内存的差方法，用递归写过输出斐波那契数列的人都知道，从第十几个数字后就开始慢的不行了，而且最近还听说某厂面试一个应届生的时候因为他用递归处理斐波那契就直接拒了他……所以还是不用的好。 由于Python中自带队列数据结构，所以通过队列实现迭代循环是目前较为理想的方案。 多线程在爬虫程序中，当我提交了请求之后CPU需要等待网站相应后才能进一步计算，也就是需要等待urllib2.urlopen()得到相应之后才能read网页的内容，所以这就需要等待一段时间，所以为了提高爬虫的效率，就需要开启多线程进程抓取。 健壮在爬虫运行的时候，如果因为被网站的防爬虫机制禁止了爬取行为，那就会导致整个爬虫程序的意外退出，所以就必须把urllib2的行为包起来。 另外，如果同一个IP在短时间内对一个网站进行大量访问，可能会被网站的防爬虫措施制裁，比如豆瓣…所以为了避免爬虫挂掉，就得设置一个时间间隔，也就是让线程暂时阻塞，等时间到了之后再加入线程队列中。 Bloom Filter在上次的遍历一个URL中的所有URL任务中，虽然一次能抓取到几千个URL，但是并不能保证这些URL都是不重复的，如果在这些URL中有环路的话，爬虫就会先入死循环中，所以对抓取到的URL进行去重就是一个要面临的问题。 当需要处理的数据很少的时候，可以用set集合来解决，但是当数据量变大的时候，就得靠Bloom Filter（布隆过滤器）了。BF的算法不算非常复杂，不过好歹有现成的轮子，用起来也方便了许多。 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&gt;&gt;&gt; from pybloom import BloomFilter&gt;&gt;&gt; f = BloomFilter(capacity=10000, error_rate=0.001)&gt;&gt;&gt; for i in range_fn(0, f.capacity):... _ = f.add(i)...&gt;&gt;&gt; 0 in fTrue&gt;&gt;&gt; f.capacity in fFalse&gt;&gt;&gt; len(f) &lt;= f.capacityTrue&gt;&gt;&gt; (1.0 - (len(f) / float(f.capacity))) &lt;= f.error_rate + 2e-18True&gt;&gt;&gt; from pybloom import ScalableBloomFilter&gt;&gt;&gt; sbf = ScalableBloomFilter(mode=ScalableBloomFilter.SMALL_SET_GROWTH)&gt;&gt;&gt; count = 10000&gt;&gt;&gt; for i in range_fn(0, count):... _ = sbf.add(i)...&gt;&gt;&gt; sbf.capacity &gt; countTrue&gt;&gt;&gt; len(sbf) &lt;= countTrue&gt;&gt;&gt; (1.0 - (len(sbf) / float(count))) &lt;= sbf.error_rate + 2e-18True``` ------------# 新任务&gt;自动向百度提交搜索请求，搜索nuist.edu.cn中包含？的URL，从返回的结果页面中，提取每一个分页中的URL，并将结果写入一个文件中。**这次强调所有结果有多少页就爬取多少页**！## 实现```Python#!/usr/bin/env python# -*- coding: utf-8 -*-import reimport timeimport Queueimport urllib2import threading from bs4 import BeautifulSoupimport sysimport urllibfrom pybloom import BloomFilterimport time# use Bloom Filterbf = BloomFilter(1000000, 0.01)# translate the default codereload(sys)sys.setdefaultencoding("utf-8")# define a queueurl_wait = Queue.Queue(0)class MyThread(threading.Thread): def __init__(self, url, num): threading.Thread.__init__(self) self.url = url # self.tnum = num def run(self): # traverse the whole url time.sleep(5) traverse(self.url) # print "This is thread-%d" % self.tnumdef find_nextpage(new_url): try: tmp = urllib2.urlopen(new_url) content = tmp.read() except: pass soup = BeautifulSoup(content) for link in soup.find_all(href=re.compile("rsv_page=1")): tmp_link = link.get('href') real_url = "http://www.baidu.com" + tmp_link return real_url def traverse(url): fp = open("all_url.txt", "a") url_wait.put(url) while not url_wait.empty(): url = url_wait.get() if url not in bf: try: content = urllib2.urlopen(url).read() soup = BeautifulSoup(content) for urls in soup.find_all(href=re.compile("http")): link = urls.get('href') url_wait.put(link) except: pass bf.add(url) fp.write( url + '\n\n') fp.close() def main(): num = 0 fp = open("target.txt", "a") url_pool = Queue.Queue(0) start_url = "http://www.baidu.com/s?wd=site:(nuist.edu.cn)%20?" url_pool.put(start_url) try: while not url_pool.empty(): new_url = url_pool.get() fp.write(new_url + "\n\n") nextpage = find_nextpage(new_url) url_pool.put(nextpage) Thread = MyThread(new_url, num) num += 1 Thread.start() except: pass fp.close() if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器]]></title>
    <url>%2F2014%2FCompiler%2FLexical-analyzer%2F</url>
    <content type="text"><![CDATA[一个词法分析器的demo。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int i, j;int len;int count;int start_p;int analyse(char *tmp, int start_p, FILE *fp_w)&#123; while( isspace(tmp[start_p]) ) start_p++; if( isalpha(tmp[start_p]) ) &#123; count = 0; char tmp_str[1000] = &#123;&#125;; while( isalpha(tmp[start_p]) ) &#123; tmp_str[count] = tmp[start_p]; count++; start_p++; &#125; start_p--; if( is_keyword(tmp_str, fp_w) )&#123; ; &#125; else &#123; printf("&lt;0, %s&gt;\n", tmp_str); fprintf(fp_w, "&lt;0, %s&gt;\n", tmp_str); &#125; &#125; else&#123; if( isdigit(tmp[start_p]) ) &#123; count = 0; char tmp_str[1000] = &#123;&#125;; while( isdigit(tmp[start_p]) ) &#123; tmp_str[count] = tmp[start_p]; count++; start_p++; &#125; start_p--; printf("&lt;1, %s&gt;\n", tmp_str); fprintf(fp_w, "&lt;1, %s&gt;\n", tmp_str); &#125; else&#123; if( !isalpha(tmp[start_p]) &amp;&amp; !isdigit(tmp[start_p]) ) &#123; count = 0; char tmp_str[1000] = &#123;&#125;; if( !isalpha(tmp[start_p+1]) &amp;&amp; !isdigit(tmp[start_p+1]) ) &#123; tmp_str[count] = tmp[start_p]; count++; start_p++; tmp_str[count] = tmp[start_p]; if( is_symbol(tmp_str, fp_w) )&#123; ; &#125;else&#123; count--; start_p--; tmp_str[1] = '\0'; tmp_str[count] = tmp[start_p]; is_symbol(tmp_str, fp_w); &#125; &#125;else&#123; tmp_str[count] = tmp[start_p]; is_symbol(tmp_str, fp_w); &#125; &#125; &#125; &#125; len = strlen(tmp); if( start_p == len ) return 1; else analyse(tmp, start_p+1, fp_w);&#125;int is_keyword(char *tmp, FILE *fp_w)&#123; char *keyword[] = &#123; "main", "void", "int", "float", "char", "double", "for", "if", "else", "while", "do", "break", "switch", "case", "struct", "typedef", "char", "return", "continue", "sizeof" &#125;; //total number:20 for (i = 0; i &lt; 20; ++i) &#123; if( strcmp( tmp, keyword[i]) == 0 ) &#123; printf("&lt;%d, %s&gt;\n", i+2, tmp); fprintf(fp_w, "&lt;%d, %s&gt;\n", i+2, tmp); return 1; &#125; &#125; return 0;&#125;int is_symbol(char *tmp, FILE *fp_w)&#123; char *symbol[] = &#123; "+", "-", "*", "/", "&lt;", "&gt;", "=", "!", "&amp;", "|", "\\", "#", "\"", "%", "^", "++", "+=", "--", "-=", "*=", "/=", "%=", "&amp;=", "^=", "|=", "&lt;=", "&gt;=", "==", "!=", "&amp;&amp;", "||", "&gt;&gt;", "&lt;&lt;", "?:", "-&gt;", "&#123;", "&#125;", "(", ")", "[", "]", ",", ";", ":", "." &#125;; //total number:45 for (i = 0; i &lt; 45; ++i) if( strcmp( tmp, symbol[i]) == 0 ) // printf("Yes! No.%d: %s\n", i, tmp); &#123; printf("&lt;%d, %s&gt;\n", 22 + i, tmp); fprintf(fp_w, "&lt;%d, %s&gt;\n", 22 + i, tmp); return 1; &#125; return 0;&#125;int is_blankline(char *tmp)&#123; int i; int len = strlen(tmp); for (i = 0; i &lt; len; ++i) &#123; if( !isspace(tmp[i]) ) return 0; &#125; return 1;&#125;int delete_comments(char *tmp)&#123; len = strlen(tmp); for(i = 0; i &lt; len; i++) &#123; if(tmp[i] == '/' &amp;&amp; tmp[i+1] == '/') &#123; tmp[i] = '\0'; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; char tmp[100] = ""; char str[100] = ""; int flag = 0; FILE *fp, *fp_tmp; fp = fopen("test.c", "r"); fp_tmp = fopen("tmp.c", "w"); while(fgets(str, 100, fp) != NULL) &#123; for(i = 0; i &lt; 100; i++) &#123; if(str[i] == '/' &amp;&amp; str[i+1] == '/') &#123; str[i] = '\n'; str[i+1] = '\0'; &#125; if(str[i] == '/' &amp;&amp; str[i+1] == '*') &#123; str[i] = '\0'; flag = 1; fputs(str, fp_tmp); &#125; if(str[i] == '*' &amp;&amp; str[i+1] == '/') &#123; for (j = 0; j &lt; 100; ++j) &#123; str[j] = str[j+i+2]; &#125; str[j] = '\0'; flag = 0; &#125; &#125; if( flag == 0 ) fputs(str, fp_tmp); &#125; fcloseall(); FILE *fp_new; FILE *fp_w; fp_new = fopen("tmp.c", "r"); fp_w = fopen("Lex_Result.txt", "w"); while(!feof(fp_new))&#123; if(fgets(tmp, 100, fp_new)) if( is_blankline(tmp) == 0) analyse(tmp, 0, fp_w); &#125; fcloseall(); remove("tmp.c"); return 0;&#125; 实例目标程序#include #include //This is a simple target code int main() { printf("TEST BEGUN!"); int a = 0; int b = 1; /* You can not see me! */ if(a]]></content>
      <tags>
        <tag>Compile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫（一）]]></title>
    <url>%2F2014%2FPython%2Fpython-crawler-1%2F</url>
    <content type="text"><![CDATA[从零开始写爬虫 一、遍历网站的全部页面思路要遍历一个网站的全部页面,要做的就是先打开目标网站的源码,从中提取所有的URL,然后再逐个遍历,并保存已处理过的URL。 1.提取URL从一堆HTML中提取可用的URL是一件轻松的事,处理的方法也有很多。 正则表达式提取 BeautifulSoup提取 自带库sgmlib中的SGMLParser类 这里就试试第三种方法。 2.存储URL提取出URL后,分开存储刚刚提取出来的URL和已经处理过的URL就是接下来要解决的问题。 一开始想过存在列表里面,但是从中提取和pop出URL的顺序又成了问题,所以这里采用Python自带的队列数据结构。 然后处理完的URL就直接存入文件,并且计数,即为已经访问到的页面数量。 3.实现函数接下来的任务就是运行函数来处理URL了,但是我现在用的只是最笨的递归,效率低下不说,对内存也是一个很大的考验。所以之后会通过多线程编程来解决这个问题,把URL放入内存池中,规定每次允许运行的线程数,这样就能在一定程度上提升效率和速度了。 4.具体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# -*- coding: UTF-8 -*-# 搜寻现成的爬虫代码，弄明白怎样遍历一个网站的全部页面，编码实现：# 能够遍历一个网站的大部分页面，保存输出可遍历页面的URL，并统计访问到的页面数量。import reimport Queueimport urllib2from sgmllib import SGMLParserurl_queue = Queue.Queue(0)url_num = 0class find_url(SGMLParser): """docstring for find_url store the urls into url_new """ def __init__(self): SGMLParser.__init__(self) self.url_new = [] def start_a(self, attrs): href = [v for k, v in attrs if k=='href'] if re.match(r'^https?:/&#123;2&#125;\w.+$', "".join(href)): self.url_new.extend(href)def open_url(): url = url + 1 url_given = url_queue.get() url_traversed.write(url_given + "\n") content = urllib2.urlopen(url_given).read() result = find_url() result.feed(content) for urls in result.url_new: # print i url_queue.put(urls) while not url_queue.empty(): open_url()if __name__ == '__main__': url = "http://movie.douban.com" url_traversed = open('URLSTORE.txt', 'w') url_queue.put(url) open_url() url_traversed.closed() print "The number of the traversed URL is %d" % url_num``` ## 二、向百度提交搜索#### 1.提交搜索我现在还是用的最笨的方法,即直接打开包含需要搜索内容的URL,就能得到搜索页面的源码。 用POST和GET提交的方法下次再用。 #### 2.处理结果 用BeautifulSoup查找&lt;div&gt;标签间的内容,但是这个还是只能大概地过滤,并不能很精准地返回搜索内容。 #### 3.待解问题1. 用POST和GET方法提交搜索。 2. 细致地处理返回的搜索结果。 3. 遍历所有的搜索结果。 ```Python# -*-coding: UTF-8 -*-# 2.用百度设置内的高级搜索功能，在指定网站中搜索URL中包含？的结果。编程实现：# 自动向百度提交搜索，在指在指定网站中搜索URL中包含？的结果，提取百度搜索结果并输出到文件。# 例如，搜索nuist.edu.cn，其实就是想百度提交搜索字符串site:(nuist.edu.cn) ?# http://www.baidu.com/s?wd=import sysimport urllib2from bs4 import BeautifulSoupreload(sys) sys.setdefaultencoding('utf8') def search_baidu(): url = urllib2.urlopen("http://www.baidu.com/s?wd=site:(nuist.edu.cn)%20?") urltmp = url.read() # urltmp = urltmp.decode("UTF-8").encode("UTF-8") soup = BeautifulSoup(urltmp) res = soup.find(name='div').getText('\n') ss = open('ss.txt', 'w') ss.write(res) ss.close()search_baidu()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于进程的问题]]></title>
    <url>%2F2014%2FOS%2Fprocess-qa%2F</url>
    <content type="text"><![CDATA[哲学家就餐问题等 一、经典的IPC问题哲学家就餐问题问题描述:5个哲学家围绕一张圆桌而坐，每个哲学家面前都有一盘通心粉，由于通心粉很滑，所以需要两把叉子才能夹住。相邻两个盘子之间有一把叉子。哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两把叉子,思考时则同时将两把叉子放回原处。 如何保证哲学家们的动作有序进行?如: 不出现相邻者同时要求进餐; 不出现有人永远拿不到叉子。 为了避免死锁，和只能让一个哲学家进餐的状态，我们可以使用下面的方法。 使用一个数组state跟踪每一个哲学家是在进餐，思考还是饥饿状态（正在试图拿叉子），一个哲学家只有在两个邻居都没有进餐时才允许进入进餐状态。 第i个哲学家由宏LEFT和RIGHT定义。比如i为2，则LEFT为1，RIGHT为3。 #define N 5 #define N 5 /*哲学家数目*/ #define LEFT (i + N - 1) % N /*i的左邻居编号*/ #define RIGHT (i + 1) % N /*i的右邻居编号*/ #define THINKING 0 /*哲学家在思考*/ #define HUNGRY 1 /*哲学家试图拿起叉子*/ #define EATING 2 /*哲学家进餐*/ typedef int seamphore; /*信号量是一种特殊的整型数据*/ int state[N]; /*数组用来跟踪记录每位哲学家的状态*/ seamphore mutex = 1; /*临界区的互斥*/ seamphore s[N]; /*每个哲学家一个信号量*/ void philosopher(int i) /*i：哲学家编号，从0到N-1*/ { while(TRUE){ /*无限循环*/ } } void take_forks(int i) /*i：哲学家编号，从0到N-1*/ { down(&mutex); /*进入临界区*/ state[i] = HUNGRY; /*记录哲学家i处于饥饿的状态*/ test(i); /*尝试获取2把叉子*/ up(&mutex); /*离开临界区*/ down(&s[i]); /*如果得不到需要的叉子则阻塞*/ } void put_forks(i) /*i：哲学家编号，从0到N-1*/ { down(&mutex); /*进入临界区*/ state[i] = THINKING; /*哲学家已就餐完毕*/ test(LEFT); /*检查左边的邻居现在可以吃吗*/ test(RIGHT); /*检查右边的邻居现在可以吃吗*/ up(&mutex); /*离开临界区*/ } void test(i) /*i：哲学家编号，从0到N-1*/ { if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING){ state[i] = EATING; up(&s[i]); } } 该程序使用了一个信号量数组，每个信号量对应一个哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞。 二、进程与线程书后习题 1.有没有可能发生阻塞到运行，就绪到阻塞的转换？ 从阻塞到运行的状态是可以的，假设某个进程在I/O上阻塞，而且I/O就此结束，如果此时CPU是空闲的话，这个进程就可以从阻塞状态直接转换到运行态。 而从就绪态转换到阻塞态是不可能的，因为一个就绪的进程是不会做诸如I/O这些会产生阻塞的事，只有运行的进程才能被阻塞。 4.内核使用单独堆栈的原因 你不会希望由于一些写的不好的用户程序没有被分配到足够多的堆栈空间而导致系统崩溃。 如果内核把数据保留在用户空间，然后从系统调用返回，那么一个恶意用户就有可能使用这些数据查找关于其他进程的信息。 5. 多个程序能够并行运行，比它们顺序执行完成的要快。假设有两个作业同时开始执行，每个需要10分钟的CPU时间。如果顺序执行，那么最后一个作业需要多长时间可以完成？如果并行执行又需要多长时间？假设I/0等待占50%。 顺序执行的时候，因为I/O频率为50%，CPU时间为10分钟，所以每个作业需要20分钟，则最后一个作业需要40分钟来完成。 并行执行时，CPU的利用率为1-0.5²，这意味着每分钟每个作业在并行时实际获得用于处理的CPU时间是0.75/2 = 0.375分钟，所以为了执行完需要10分钟的CPU时间的工作，每个作业必须运行10/0.375≈26.67分钟。又因为是并行的，相当于两个作业同时完成，因此是26.67分钟。 7.如果创建一个多线程进程，若子进程得到全部父进程线程的副本，会出现问题。假如原有线程之一正在等待键盘输入，现在则成为两个线程在等待键盘输入，每个进程有一个。在单线程进程中也会发生这种问题吗？不会。如果单线程进程在键盘上阻塞，就不能创建子进程。 8.在多线程Web服务器中，如果读取文件的唯一途径是正常的阻塞read系统调用，那么Web服务器应该使用用户级线程还是内核级线程，为什么？用内核级线程。当一个工作线程从磁盘读取一个网页时，它就会被阻塞。如果使用了用户级线程，那这个动作就会阻塞整个进程，那么多线程就没有意义了。所以就应该使用内核级线程，这样在一些线程阻塞时就不会影响其他线程。 11.为什么线程要通过调用thread_yield自愿放弃CPU？毕竟，由于没有周期性的时钟中断，线程可以不交回CPU。进程中的线程通常是相互协作而不是相互独立的，如果放弃是对应用程序的有利需要的话，那么线程将放弃CPU。毕竟通常都是一个程序员写所有的代码。 12.线程可以被时钟中断抢占吗？如果可以，什么情形下可以？如果不可以，为什么不可以？用户级线程不可以被时钟剥夺，除非整个进程的时间片被用完。内核级的线程可以单独地被剥夺。在后一种情况中，如果一个线程运行太久，那么时钟会终端当前的进程，因此当前的线程也被中断。内核可以自由地从同一个进程中选取其他线程运行。 13.对使用单线程文件服务器和多线程服务器读取文件进行比较。假设所需要的数据都在高速缓存中，花费15ms获得工作请求，分派工作，并处理其余必要工。如果在三分之一时间时，需要一个磁盘操作，要另外花费75ms，此时该线程进入睡眠。在单线程情形下服务器每秒可以处理多少个请求？如果是多线程呢？ 在单线程的情况下，cache命中需要15ms，没命中需要90ms。那加权平均时间为2/3x15 + 1/3x90，因此平均请求时间为40ms，所以服务器一秒可以处理25个请求。 对于一个多线程服务器，所有的磁盘等待都是重叠的，所以每个请求花费15ms，所以服务器可以每秒处理200/3个请求。 14.在用户空间实现线程，其最大的优点是什么？最大的缺点是什么？ 用户级线程包可以在不支持线程的操作系统上实现 允许每个进程有自己定制的调度算法 如何实现阻塞系统调用 如果一个线程开始运行，那么在该线程中的其他线程就不能运行，除非第一个线程自动放弃CPU。 最大的优点是效率。No traps to the kernel are needed to switch threads. 最大的缺点是如果一个线程发生阻塞，那整个进程就阻塞了。 38.运行在CTSS上的一个进程需要30个时间片完成。该进程必须被调入多少次，包括第一次（在该进程运行之前）？第一次得到1个时间片。随后获得2,4,8,15个时间片，因此必须经过5次交换。 41.一个软实时系统有4个周期时间，其周期分别为50ms，100ms，200ms和250ms。假设这4个事件分别需要35ms，20ms，10ms和x ms的CPU时间。保持系统可调度的最大x值是多少？所使用的CPU的片断为35/50 + 20/100 + 10/200 + x/250。为了使得进程可调度，必须是总和小于1。因此，x必须小于12.5ms。 42.请解释为什么两级调度比较常用？当内存太小不能载入所有就绪进程时，就需要使用两级调度。某些进程被载入内存，并且从中选择一个运行。内存中进程会随着时间调整。这种算法容易实现也非常有效，另外，时间片轮转调度并不管进程是否在内存中。 43.一个实时系统需要处理两个语音通信，每个运行5ms，然后每次突发消耗1ms CPU时间，加上25帧/秒的一个视频，每一帧需要20ms的CPU时间。这个系统是可调度的吗？每个语音通信每秒运行200次并且每次突发消耗1ms，所以每个语音通信需要200ms每秒或者两个需要400ms每秒。视频每秒运行25次并且每次消耗20ms，一共是500ms每秒。它们每秒一共消耗900ms，所以有时间剩余，系统可调用。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间调度]]></title>
    <url>%2F2014%2FOS%2Fschedule%2F</url>
    <content type="text"><![CDATA[当计算机系统是多道程序设计系统时，通常就会有多个进程或者线程同时竞争CPU。只要有两个或者多个进程处于就绪状态，这种情况就会发生。如果此时只有一个CPU可用，那么就必须选择下一个要运行的进程。 在操作系统中完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。 一、何时调度 在创建一个新进程后，需要决定是运行父进程还是运行子进程。 在一个进程退出时必须做出调度决策。 当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。 在一个I/O中断发生时，必须做出调度决策。 在分时系统中，当一个时钟中断发生时。 二、调度算法1.先来先服务FCFS(first-come first-served)这是最简单的调度算法,按先后顺序调度。 按照作业提交或进程变为就绪状态的先后次序,分派CPU; 当前作业或进程占用CPU,直到执行完或阻塞,才出让CPU(非抢占方式)。 在作业或进程唤醒后(如I/O完成),并不立即恢复执行,通常等到当前作业或进程出让CPU。最简单的算法。 FCFS的特点 比较有利于长作业,而不利于短作业。 有利于CPU繁忙的作业,不利于I/O繁忙的作业。 2.最短作业优先SJF(shortest job first)这是对FCFS算法的改进，目的是为了缩短平均周转时间。 对预计执行时间短的作业(进程)优先分派处理机。通常后来的短作业不抢先正在执行的作业。 SJF的特点优点: 比FCFS改善平均周转时间和平均带权周转时间,缩短作业的等待时间; 提高系统的吞吐量;缺点: 对长作业非常不利,可能长时间得不到执行; 未能依据作业的紧迫程度来划分执行的优先级; 难以准确估计作业(进程)的执行时间,从而影响调度性能。 3.轮转调度一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段内运行。 如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。 如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。 时间片长度变化的影响 过长-&gt;退化为FCFS算法,进程在一个时间片内都执行完,响应时间长。 过短-&gt;用户的一次请求需要多个时间片才能处理完,上下文切换次数增加,响应时间长。 时间片长度的确定 系统的响应时间: T(响应时间) = N(进程数目) * q(时间片) 就绪进程的数目: 数目越多,时间片越小 系统的处理能力: 应当使用户输入通常在一个时间片内能处理完,否则使响应时间,平均周转时间和平均带权周转时间延长。 4.优先级调度基本思想：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。 优先级又被分为静态优先级和动态优先级。 静态优先级创建进程时就确定,直到进程终止前都不改变。通常是一个整数。依据: 进程类型(系统进程优先级较高) 对资源的需求(对CPU和内存需求较少的进程,优先级较高) 用户要求(紧迫程度和付费多少) 动态优先级在创建进程时赋予的优先级,在进程运行过程中可以自动改变,以便获得更好的调度性能。如: 在就绪队列中,等待时间延长则优先级提高,从而使优先级较低的进程在等待足够的时间后,其优先级提高到可被调度执行; 进程每执行一个时间片 就降低其优先级 从而一个进程持续执行时,其优先级降低到出让CPU。 三、线程调度当若干进程都有多个线程时，就存在两个层次的并行：线程和进程。 在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或者两者都支持）。 用户级线程因为内核不知道有线程的存在，所以内核还是像以前一样操作，选取一个进程，假设为A，并给予A以时间片控制。A中的线程调度程序决定哪个线程运行，假设为A1。 由于多道线程并不存在时钟中断，所以这个线程可以随意运行多长时间，如果该线程用完了进程的所有时间片，内核就会选择另外一个进程运行。 在进程A终于又一次运行时，线程A1会接着运行。该线程会继续耗费A进程的所有时间，直到它完成工作。并且这种行为不会影响到其他的进程。 现在考虑A线程每次CPU计算的工作比较少的情况，例如在50ms的时间片里有5ms的计算工作。于是，每个线程运行一会儿，然后把CPU交回给线程调度程序。 这样在内核切换到进程B之前，就会有序列A1,A2,A3,A1,A2,A3,A1,A2,A3,A1。如下图所示。 内核级线程内核选取一个特定的线程运行，它不用考虑该线程属于哪个进程（如果有必要它也可以这样做）。内核对被选择的线程赋予一个时间片，如果超出了时间片就会强行挂起这个线程。 一个线程在50ms的时间片内，5ms之后被阻塞，在30ms的时间段中，线程的顺序会是A1,B1,A2,B2,A3,B3。如下图所示。 用户级线程和内核级线程之间的差别在于性能。 用户级线程的线程切换需要少量的机器指令； 内核级线程需要完整的上下文切换，修改内存印象，使高速缓存失效，这导致了若干数量级的延迟。 另一方面，在使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信]]></title>
    <url>%2F2014%2FOS%2Fcommunication%2F</url>
    <content type="text"><![CDATA[进程经常需要与其他进程通信，所以我们就来讨论一些关于进程间通信(Inter Process Communication, IPC)的问题。 一、竞争状态(race condition) 两个或多个进程对同一共享数据同时进行读写操作，而最后的结果是不可预测的，它取决于各个进程具体运行情况。 在同一时刻，只允许一个进程访问该共享数据，即如果当前已有一个进程正在使用该数据，那么其他进程暂时不能访问。这就是互斥的概念。 那么为了避免竞争状态，我们就需要互斥，也就是当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。这样就引入了临界区的概念。 二、临界区临界区的定义： 每个进程中访问临界资源的那段代码称为临界区。临界资源指的是一次只允许一个进程使用的资源称为临界资源，例如打印机、变量。 所以如果我们能通过适当的安排，使得两个进程不可能同时处于临界区中，就能避免竞争状态。 尽管这样的要求避免了竞争状态，但它还不能保证使用共享数据的并发进程能够正确和高效地进行协作。所以对于一个好的解决方案，需要满足一下4个： 任何两个进程都不能同时进入临界区; 不应对CPU的速度和数量做任何假设; 临界区外运行的进程不得阻塞其他进程; 不得使进程无限期等待进入临界区。 三、同步机制应遵循的准则1.空闲让进 临界自愿处于空闲状态,允许进程进入临界区 临界区内仅有一个进程执行 2.忙则等待 临界区有进程正在执行其中的代码,所有其他进程则不可以进入临界区 3.有限等待 对要求访问临界区的进程 应在保证在有限时间内进入自己的临界区,避免死等。 4.让权等待 当进程不能进入自己的临界区时,应立即释放处理机,避免忙等。 四、实现互斥的方案1.屏蔽中断在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前打开中断。屏蔽中断后，时钟中断也会被屏蔽。CPU只有在发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断后CPU就不会被切换到其他进程。 2.锁变量假设有一个共享变量，初始值为0。当一个进程想进入临界区时，它就会首先测试这把锁。如果锁的值为0，则该进程就将其设置为1并进入临界区。如果锁的值已经为1，那么进程就一直等待直到锁的值为0.所以0就表示临界区内没有进程，1表示已经有某个进程进入临界区。 3.严格轮换法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647while(TRUE)&#123; while(turn != 0) critical_region(); /*循环*/ turn = 1; noncritical_region();&#125;``` &gt;a) ```Cwhile(TRUE)&#123; while(turn != 1) critical_region(); /*循环*/ turn = 0; noncritical_region();&#125;``` &gt;b) ### 4.Peterson解法在进入临界区前，各个进程使用其进程号0或1作为参数来调用enter_region。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作后，进程将调用leave_region，表示操作已完成，若其他进程希望进入临界区，则现在就可以进入。 ```C#define FALSE 0#define TRUE 1#define N 2 /*进程数量*/ int turn; /*现在轮到谁？*/int interested[N]; /*所有值初始化为0(FALSE)*/void enter_region(int process) /*进程是0或1*/&#123; int other; /*其他进程号*/ other = 1 - process; /*另一方进程*/ interested[process] = TRUE; /*表明所感兴趣的*/ turn = process; /*设置标志*/ while(turn == process &amp;&amp; interested[other] == TRUE); /*空语句*/&#125;void leave_region(int process) /*进程：谁离开？*/&#123; interested[process] = FALSE; /*表示离开临界区*/&#125; 五、生产者-消费者问题生产者-消费者问题又称为有界缓冲区问题。两个进程共享一个公共的固定大小的缓冲区。 其中一个是生产者，将消息放入缓冲区；另一个是消费者，从缓冲区中取出消息。 而问题在于当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况。其解决方法是让生产者睡眠，待消费者从缓存区中取出一个或多个数据项时再唤醒它。 当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define N 100 /*缓冲区中的槽数目*/int count = 0; /*缓冲区中的数据项数目*/void producer(void)&#123; int item; while(TRUE)&#123; /*无限循环*/ item = produce_item(); /*产生下一新数据项*/ if(count == N) sleep(); /*如果缓冲区满了，就进入休眠状态*/ insert_item(item); /*将新数据项放入缓冲区中*/ count = count + 1; /*将缓冲区的数据项计数器增1*/ if(count == 1） wakeup(consumer); &#125;&#125;void consumer(void)&#123; int item; while(TRUE)&#123; /*无限循环*/ if(count == 0) sleep(); /*如果缓冲区空，则进入休眠状态*/ item = remove_item(); /*从缓冲区中取出一个数据项*/ count = count - 1; /*将缓冲区的数据项计数器减1*/ if(count == N - 1) wakeup(producer); /*缓冲区满吗？*/ consume_item(item); /*打印数据项*/ &#125;&#125;``` 这里还是有可能会出现竞争状态，其原因是对count的访问未加限制。 我们来看这样一个情况：缓冲区为空，消费者刚刚读取count的值发现它为0，此时调度程序决定暂停消费者而唤醒生产者。生产者向缓冲区中加入一个数据项，count加1。现在count的值变成1了，它推断由于count刚刚为0，所以消费者一定在睡眠，于是生产者调用**wakeup**来唤醒消费者。 但此时消费者并没有睡眠，所以这个**wakeup**信号就会丢失，当消费者下次运行时，它将测试先前读到的count值，发现它为0，于是睡眠。而生产者迟早会填满整个缓冲区，然后睡眠，这样一来，两个进程将永远睡眠下去。 所以现在问题的实质在于一个wakeup信号的丢失。虽然在这里我们可以加上一个**唤醒等待位**，但当问题中有三个或者更多进程时一个唤醒等待位就不够了，所以这并没有从本质上解决问题。 ## 六、信号量E.W.Dijkstra提出一种方法，它使用一个整型变量来累计唤醒次数，供以后使用。 这个引入的新变量类型就叫做**信号量(semaphore)**。 一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或正值（表示有一个或多个唤醒操作）。 Dijkstra建议设立两种操作：down(P)和up(V)。 - down 如果信号量的值大于0，则将其值减1并继续； 若该值为0，则进程将睡眠。并将继续down操作。 - up 对信号量的值增1。 ### 用信号量解决生产者-消费者问题#### 该方案使用了三个信号量：- **full** 用来记录充满的缓冲槽数目；- **empty** 记录空的缓冲槽总数；- **mutex** 确保生产者和消费者不会同时访问缓冲区。 full的初值为0，empty的初值为缓冲区中槽的数目，mutex初值为1。供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区，称为二元信号量。如果每个进程在进入临界区前都执行一个down操作，并在刚刚退出时执行一个up操作，就能够实现互斥。 ```C#define N 100 /*缓冲区中的槽数目*/typedef int semaphore; /*信号量是一种特殊的整型数据*/semaphore mutex = 1; /*控制对临界区的访问*/semaphore empty = N; /*计数缓冲区的空槽数目*/semaphore full = 0; /*计数缓冲区的满槽数目*/void producer(void)&#123; int item; while(TRUE)&#123; /*TRUE是常量1*/ item = produce_item(); /*产生放在缓冲区中的一些数据*/ down(&amp;empty); /*将空槽数目减1*/ down(&amp;mutex); /*进入临界区*/ insert_item(item); /*将新数据项放到缓冲区中*/ up(&amp;mutex); /*离开临界区*/ up(&amp;full); /*将满槽的数目加1*/ &#125;&#125;void consumer(void)&#123; int item; while(TRUE)&#123; /*无限循环*/ down(&amp;full); /*将满槽数目减1*/ down(&amp;mutex); /*进入临界区*/ item = remove(); /*从缓冲区中取出数据项*/ up(&amp;mutex); /*离开临界区*/ up(&amp;empty); /*将空槽数加1*/ consumer_item(item); /*处理数据项*/ &#125;&#125;]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2014%2FOS%2Fprocess-and-thread%2F</url>
    <content type="text"><![CDATA[操作系统中最核心的概念就是进程：这是对正在运行程序的一个抽象。 一、进程的定义 进程是程序的一次执行。 进程 = 进程控制块 + 程序 + 数据。 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 二、进程的结构一个进程中应该包括： 程序的代码； 程序的数据； 程序计数器中的值，用来指示下一条将运行的指令； 一组通用的寄存器的当前值、堆、栈； 一组系统资源（如打开的文件）； 三、进程的创建：4个因素1.系统初始化。2.执行了正在运行的进程所调用的进程创建系统调用。3.用户请求创建一个新进程。4.一个批处理作业的初始化。 在UNIX系统中，只有一个系统调用可以用来创建新进程：fork。 四、进程的终止：4种原因 正常退出（自愿的）。 出错退出（自愿的）。 严重错误（非自愿）。 被其他进程杀死（非自愿）。 五、进程的状态进程有三种基本状态： 运行态该时刻进程实际占用CPU。 就绪态可运行，但因为其他进程正在运行而暂时停止。进程已获得除处理机外的所需资源，等待分配处理机资源，只要分配CPU就可执行。 阻塞态正在执行的进程，由于发生某种事件而暂时无法执行，便放弃处理机处于暂停状态。 1.运行→阻塞：进程为等待输入而阻塞2.运行→就绪：调度进程选择另一个程序3.就绪→运行：调度进程选择这个进程4.阻塞→就绪：出现有效输入 在操作系统发现进程不能继续运行下去时，发生转换1。 系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2。 在系统已经让所有其他进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会发生转换3。 当进程等待的一个外部事件发生时（如一些输入达到），则发生转换4。 转换2、3都是由进程调度程序引起的。 调度程序的主要工作就是决定应当运行哪个进程、何时运行以及它应该运行多长时间。 六、进程的实现操作系统为了实现进程模型，维护着一张叫做进程表(process table)的表格，每个进程占用一个进程表项。（在学校的教材上这个进程表项叫做进程控制块PCB）。 进程控制块PCB是进程的唯一标志。 进程控制块中包含了进程状态的重要信息，包括： 程序计数器（PC） 堆栈指针 内存分配状态 所打开文件状态 账号和调度信息 优先级 互斥和同步机制 … 正是这些信息保证了进程在经历了各种转换后能再次启动，就像从未被中断过一样。 七、线程上面的内容中，我们讨论了关于进程的话题，但是在实际运用当中并不是每次都只运行一个进程的，所以我们就需要提出一个新的实体，来满足一下特性： 实体之间可以并发地执行； 实体之间共享相同的地址空间； 而进程包含了两个概念：资源拥有者和可执行单元，这个可执行单元就称为线程。 尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。 进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。 在前一种情形中，多个线程共享同一个地址空间和其他资源。 在后一种情形下，多个进程共享物理内存、磁盘、打印机个和其他资源。 八、引入线程的目的 减小进程切换的开销 提高进程内的并发程度 共享资源 那么问题来了，引入进程和线程的好处分别是什么？ 引入进程的好处 多个程序可以并发执行，改善资源使用率，提高系统效率。 引入线程的好处 减少并发程序执行时所付出的时空开销，使得并发粒度更细，并发性更好。 九、多线程的原因：1.主要原因是，在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞，通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。2.线程比进程更加轻量级，所以线程比进程更加容易（更快）创建和撤销。3.如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动重叠进行，从而加快应用程序的执行速度。4.在多CPU系统中，多线程是有益的，并且真正的并行有了实现的可能。 十、线程中包括： 程序计数器：记录接着要执行哪一条指令。 寄存器：保存线程当前的工作变量。 堆栈：记录执行历史。 线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。 十一、线程的实现在用户空间中实现线程把整个线程包放在用户空间中，这样用户级线程包可以在不支持线程的操作系统上实现，通过这一方法就可以用函数库实现线程。 #include #include #include #include #define NUMBER_OF_THREADS 10 void *print_hello_world(void *tid) { /*本函数输出线程的标识符，然后退出。*/ printf("Hello World.Greetings from thread %d0", tid); pthread_exit(NULL); } int main(int argc, char const *argv[]) { /*主程序创建10个进程，然后退出。*/ pthread_t threads[NUMBER_OF_THREADS]; int status, i; for(i = 0; i < NUMBER_OF_THREADS; i++){ printf("Main here.Creating thread %d0\n", i); status = pthread_creat(&threads[i], NULL, print_hello_world, (void *)i); if(status != 0){ printf("Oops.pthread_creat return error code %d0", status); exit(-1); } } exit(NULL); } 在内核中实现线程内核级线程就是内核有好几个分身，一个分身可以处理一件事的意思。这用来处理非同步事件很有用, 内核可以对每个非同步事件生个分身来处理。 内核级线程的操作非常轻便,几乎没有负担,而且对内核的结构有帮助。支持内核级线程的内核称作多线程内核。 例子：Windows 95/98/NT/2000, Solaris,Tru64 UNIX,Linux 以上的内容只是对进程与线程的概念以及一些其他的基础问题做了简单的阐述，在操作系统中关于进程内容的核心知识还得是进程的调度与通信，这两个问题留到下一篇讨论。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆瓣爬虫]]></title>
    <url>%2F2014%2FPython%2Fdouban-crawler%2F</url>
    <content type="text"><![CDATA[可抓取豆瓣读书、电影、音乐中任意标签下内容 在我刚刚入门Python爬虫的时候，无论怎样都很难找到一个适当的实例让我参考。 看过很多别人的例子，但都觉得不得要领，所以在折腾很久后写了这个简单的例子。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: UTF-8 -*-# 如果要在python2的py文件里面写中文，则必须要添加一行声明文件编码的注释，否则python2会默认使用ASCII编码。 import re import urllib2def douban_crawler(url_head, target): for page in range(0, 1000, 20): #这个1000是检索的条目数量，可以按需设定 url_rear = "?start=%d&amp;type=T" % page url_use = url_head + url_rear #两段合成真正的url content = urllib2.urlopen(url_use).read() content = content.decode("UTF-8").encode("UTF-8") content = content.replace(r'title="去FM收听"', "") content = content.replace(r'title="去其他标签"', "") name = re.findall(r'title="(\S*?)"', content, re.S) #正则表达式捕获标题 num = re.findall(r'&lt;span\s*class="rating_nums"&gt;([0-9.]*)&lt;\/span&gt;', content) #正则表达式捕获分数 doc = zip(name, num) #将标题和分数打包成([ , ][ , ]...)的形式 if target == "book": dou = open("doc_book.txt", 'a') elif target == "music": dou = open("doc_music.txt", 'a') elif target == "movie": dou = open("doc_movie.txt", 'a') for i in doc: dou.write(i[0] + " " + i[1] + "\n") #写入 dou.close()if __name__ == '__main__': target = raw_input("豆瓣 book movie music，你想爬哪一个? ") tag = raw_input("请输入你想要检索的标签: ") url_head = "http://%s.douban.com/tag/%s" % (target, tag) douban_crawler(url_head, target) print "抓取完毕" 抓取结果 豆瓣读书-小说 月亮和六便士 9.0百年孤独 9.2解忧杂货店 8.7追风筝的人 8.8霍乱时期的爱情 9.0平凡的世界（全三部） 9.0围城 8.9活着 9.1一九八四 9.3人生的枷锁 9.0陆犯焉识 8.7… 豆瓣电影-悬疑 盗梦空间 9.2寒战 7.4嫌疑人X的献身 7.4七宗罪 8.7致命ID 8.5云图 8.0禁闭岛 8.5蝴蝶效应 8.6致命魔术 8.8恐怖游轮 8.2… 豆瓣音乐-pop 十二新作 8.2Alright,Still 7.7范特西 8.5Apologize 8.9逆光 7.3Spin 8.5阿岳正传 8.3感官/世界 8.7八度空间 7.5PCD 8.4…]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统名词概念解释]]></title>
    <url>%2F2014%2FOS%2Fos-1%2F</url>
    <content type="text"><![CDATA[简单解释一些容易混淆的学术性名词。 系统吞吐量 指系统在单位时间内所完成的总工作量 作业的周转时间 指从作业进入系统开始，直至其完成并退出系统为止所经历的时间 批处理 批处理(batch processing )就是将作业按照它们的性质分组（或分批），然后再成组（或成批）地提交给计算机系统，由计算机自动完成后再输出结果，从而减少作业建立和结束过程中的时间浪费。 批处理系统 单道批处理系统内存中永远仅有一道作业的批处理操作系统称为单道批处理系统 多道批处理系统内存中可同时存在若干道作业的批处理操作系统称为多道批处理系统用户所提交的作业都先存放在外存上并排成一个队列，称为”后备队列”，然后作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使他们共享CPU和系统中的各种资源。 分时系统 利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 实时系统 系统特征是将时间作为关键参数。能够在”指定”或者”确定”的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统,实时意思就是对响应时间有严格要求,要以足够快的速度进行处理.分为硬实时和软实时两种。 硬实时：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。 软实时：虽然也联系着一个截止时间，但是超过了也可以接受，并且不会引起任何永久性的损害。 处理机与处理器 处理机：计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位。处理机包括中央处理器，主存储器,I/O接口。 处理器：即中央处理器（CPU），其功能主要是解释计算机指令以及处理计算机软件中的数据。 并行和并发 并行指两个或多个事件在同一时刻发生 并发指两个或多个事件在同一时间间隔内发生 地址空间 是指从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。 地址空间里存放可执行程序、程序的数据、程序的堆栈。 从概率的角度来看CPU的利用率假设一个进程等待I/O操作的时间与其停留在内存中时间的比为P。当内存中同时有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p^n。CPU的利用率为： CPU利用率 = 1 - p^n]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单分治]]></title>
    <url>%2F2014%2FAlgorithm%2Fdivide-and-conquer%2F</url>
    <content type="text"><![CDATA[在之前的排序算法中，我们提到了一种叫归并排序的算法，就是通过把待排序的数列分成一个个小的数列并排序成有序表，再将这些小的有序表组合成一个新的有序表来完成排序，所以归并排序算法就是利用分治策略的一个很好的典型。 概念阐述在分治策略中我们用递归的方法来求解一个问题，在每一层的递归中应用如下的三个步骤： 分解(Dived)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。 解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。 合并(Combine)步骤将子问题的解组合成原问题的解。 简单通俗地来说，所谓的分治策略就是把很复杂的问题用递归的方式细化成一个个小的，能够解决子问题，再把所有子问题的解合并起来，就得到原问题的解。 下面就通过一个例子来简单介绍分治策略。 实例问题这里有一个数组A： [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7] 现在要求寻找数组A中和最大的非空连续子数组（我们称这样的连续子数组为最大子数组）。 暴力求解法乍一看到这个问题，首先想到的当然就是简单粗暴地套上双重循环，尝试每对可能的组合，再进行比较，得出最终结果，这就是我们常说的暴力求解法，算法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//最大子数组问题：暴力求解法#include &lt;stdio.h&gt;int main()&#123; int A[] = &#123; 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, 22, 15, -4, 7 &#125;; int length = sizeof( A ) / sizeof( int ); int max = -1000; int i, j, k, sum, step, left; for( i = 1; i &lt;= length; i++ ) &#123; for( j = 0; ( j + i -1 ) &lt;= length-1; j++ ) &#123; sum = 0; for( k = j; k &lt;= j + i - 1; k++ ) sum += A[ k ]; if( sum &gt; max ) &#123; max = sum; left = j; step = i; &#125; &#125; &#125; printf("length:%d, max:%d, left:%d, right:%d, step:%d\n", length, max, left, left+step-1, step); getchar(); return 0;&#125;``` ---但是套上两个循环后，算法的时间复杂度就变为了O(n²)，我们还有更好的方法。 ---## 分治策略求解法现在我们假设要寻找子数组`A[low..high]`的最大子数组，使用分治就意味着要把数组A分成两个规模尽量相等的子数组，也就是说找到数组的中央位置mid，然后考虑求解两个子数组`A[low..mid]`和`A[mid+1..high]`。这时的最大子数组`A[i..j]`所在的位置必然是如下三处：- 完全处于子数组`A[low..mid]`中，因此 `low ≤ i ≤ j ≤ mid`。- 完全处于子数组`A[mid+1..high]`中，因此 `mid+1 ≤ i ≤ j ≤ high`。- 跨越了中点mid，因此 `low≤ i ≤ mid &lt; j ≤ high`。 接下来我们就可以递归地求解数组`A[low..mid]`和`A[mid+1..high]`的最大子数组，因为这两个子问题仍然是最大子数组问题，只是规模更小，因此剩下的子工作就是在这三个子数组的最大子数组中找出最大的一个。任何跨中点的最大子数组都由两个子数组`A[i..mid]`和`A[mid+1..j]`组成，其中low≤ i ≤ mid且mid &lt; j ≤ high，因此只要找到形如`A[i..mid]`和`A[mid+1..j]`的最大子数组，然后将其合并即可，对此算导给出了如下的伪代码： FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high ) left-sum = -100000 sum = 0 for i = mid downto low sum = sum + A[i] if sum &gt; left-sum left-sum = sum max-left = i right-sum = -100000 sum = 0 for j = mid + 1 to high sum = sum + A[i] if sum &gt; right-sum right-sum = sum max-right = j return (max-left, max-right, left-sum + right-sum) 123456---有了线性时间的FIND-MAX-CROSSING-SUBARRRY，我们就可以设计求解最大子数组问题的分治算法的伪代码： --- FIND-MAXIMUM-SUBARRAY(A, low, high)if high == low return ( low, high, A[low] );else mid = ( low + high ) / 2 ( left-low, left-high, left-sum ) = FIND-MAXIMUM-SUBARRAY( A, low, mid ) ( right-low, right-high, right-sum ) = FIND-MAXIMUM-SUBARRAY( A, mid + 1, high ) ( cross-low, cross-high, cross-sum ) = FIND-MAX-CROSSING-SUBARRRY( A, low, mid, high ) if left-sum &gt;= right-sum and left-sum &gt;= cross-sum return ( left-low, left-high, left-sum ) elseif right-sum &gt;= left-sum and right-sum &gt;= cross-sum return ( right-low, right-high, right-sum ) else return ( cross-low, cross-high, cross-sum )123456---具体实现代码如下： --- //最大子数组问题：分治策略法 #include int last_low, last_high; intfind_max_cro_arr( int A[], int low, int mid, int high ){ int i, j; int left_sum = -100000; int sum = 0; for( i = mid; i &gt;= low; i– ){ sum += A[ i ]; if( sum &gt; left_sum ) { left_sum = sum; last_low = i; } } int right_sum = -100000; sum = 0; for( j = mid + 1; j &lt;= high; j++ ){ sum = sum + A[ j ]; if( sum &gt; right_sum ) { right_sum = sum; last_high = j; } } return left_sum + right_sum; } intfind_max_arr( int A[], int low, int high ){ int left_sum, right_sum, cross_sum; if( high == low ) return A[ low ]; else { int mid = ( low + high ) / 2; left_sum = find_max_arr( A, low, mid ); right_sum = find_max_arr( A, mid + 1, high ); cross_sum = find_max_cro_arr( A, low, mid, high ); if ( left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum ) return left_sum; else if ( right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum ) return right_sum; else return cross_sum; } } intmain(){ int A[] = { 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 }; int length = sizeof( A ) / sizeof( int ); int sum = find_max_arr( A, 0, length - 1 ); printf(“max_sum:%d, low:%d, high:%d\n”, sum, last_low, last_high); getchar(); return 0; }``` 参考资料：《算法导论：第三版》。]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（二）]]></title>
    <url>%2F2014%2FAlgorithm%2Fsort2%2F</url>
    <content type="text"><![CDATA[上一篇介绍了几种简单的排序算法，这一篇来谈谈归并排序和快速排序。 归并排序（Merge Sort）顾名思义，归并算法就是将两个或两个以上的有序表组合成一个新的有序表，所以归并排序算法是递归算法的一个很好的实例。 算法原理归并操作的过程如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 举个例子吧: [ 10 4 6 3 8 2 5 7 ][ 10 4 6 3 ] [ 8 2 5 7 ][ 10 4 ] [ 6 3 ] [ 8 2 ] [ 5 7 ][ 10 ] [ 4 ] [ 6 ] [ 3 ] [ 8 ] [ 2 ] [ 5 ] [ 7 ][ 4 10 ] [ 3 6 ] [ 2 8 ] [ 5 7 ][ 3 4 6 10 ] [ 2 5 7 8 ][ 2 3 4 5 6 7 8 10 ] 算法分析 最差时间复杂度：O(nlogn) 最优时间复杂度：O(n) 平均时间复杂度：O(nlogn) 算法稳定性归并排序是一种稳定的排序方法 算法实现//归并排序 typedef int ElemType; void Merge( ElemType A[], ElemType TmpArray[], int Lpos, int Rpos, int RightEnd ); void MSort( ElemType A[], ElemType TmpArray[], int Left, int Right ); void Mergesort( ElemType A[], int N ); void Merge( ElemType A[], ElemType TmpArray[], int Lpos, int Rpos, int RightEnd ) { int i, LeftEnd, NumElements, TmpPos; LeftEnd = Rpos - 1; TmpPos = Lpos; NumElements = RightEnd - Lpos + 1; while( Lpos]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（一）]]></title>
    <url>%2F2014%2FAlgorithm%2Fsort%2F</url>
    <content type="text"><![CDATA[回顾基础的排序算法 在数据结构这门课程里，学校的老师们是较侧重于教学生如何利用诸如C语言来实现线性表，队列，栈，树这些简单的数据结构，理解这些数据结构的用法，而往往轻视了后半块关于图论，排序，查找等偏算法分析方面的内容的教学。 虽然课程的名字叫做数据结构，但很多CS强校和国外的著作都习惯地把它称作“数据结构与算法分析”。说到底，数据结构只能算是对编程语言使用的一个延伸，很多程序设计入门书诸如《C Primer Plus》和《C和指针》的后半段都会谈一些链表，树等内容，所以现在回过头来看，前面数据结构的学习还是为了在后面实现一些复杂的算法的时候，能够更好地利用这些结构来处理数据和实现算法中的思想。 在期末考试中，我们最后的大题目往往都是解答题，要求学生用编程语言实现诸如快速排序这样的算法，那么这样来看的话，独立实现这些复杂的算法，便就是真正考验这门课程是否学好的重要标准之一。 这一篇就先回顾排序算法。 冒泡排序（Bubble Sort）冒泡排序是一种比较简单的排序算法，通常被用来对于刚入门学习程序设计的学生介绍算法的概念。 算法原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法分析： 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数(n-1)和记录移动次数(0)均达到最小值。所以，冒泡排序最好的时间复杂度为O(n)。 若初始文件是反序的，需要进行趟排序。每趟排序要进行次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：O(n²) 冒泡排序的最坏时间复杂度为O(n²)。 综上，因此冒泡排序总的平均时间复杂度为O(n²)。 算法稳定性：由于冒泡算法的核心思想就是把小的元素往前调，大的元素往后调，相同的元素不做处理，所以即使相同的元素中间还隔着其他元素，这两个元素也不会发生交换，所以冒泡排序是一种稳定的排序算法。 算法实现：1234567891011121314151617typedef int ElemType;void BubbleSort( ElemType A[], int N )&#123; int i, j; ElemType Tmp; for( i = 0; i &lt; N - 1; i++) for( j = 0; j &lt; N - 1 - i; j++) &#123; if( A[ j ] &gt; A[ j + 1] ) &#123; Tmp = A[ j ]; A[ j ] = A[ j + 1]; A[ j + 1] = Tmp; &#125; &#125;&#125; 插入排序(Insertion Sort)插入排序由N-1趟排序组成，并且利用了这样的事实：位置0到位置P-1上的元素是排过序的。 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法原理： 从第一个元素开始，该元素可以认为已经被排序。 取出下一个元素，在已经排序的元素序列中从后向前扫描。 如果该元素（已排序）大于新元素，将该元素移到下一位置。 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。 将新元素插入到该位置后 重复步骤2~5 算法分析： 由于嵌套循环的每一个都花费N次迭代，因此插入排序为O(n²)，而且这个界是精确的，因为以反序输入同样可以达到该界。 如果输入数据是有序的，那么运行时间为O(n)，因为内层的for循环的检测总是立即判定不成立而终止。 综上，插入排序的平均情形也是O(n²)。 算法稳定性：插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。 算法实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778typedef int ElemType;void InsertionSort( ElemType A[], int N )&#123; int j, P; ElemType Tmp; for( P = 1; P &lt; N; P++ ) &#123; Tmp = A[ P ]; for( j = P; j &gt; 0 &amp;&amp; A[ j - 1 ] &gt; Tmp; j-- ) A[ j ] = A[ j - 1 ]; A[ j ] = Tmp; &#125;&#125;``` ---# 希尔排序：(Shell Sort)希尔排序是插入排序的一种更高效的改进版本，通过比较相距一定距离的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止，所以希尔排序有时也叫缩小增量排序。 增量是希尔排序的重要部分，只要最终增量为1任何增量序列（*increment sequence*）都可以工作。算法最开始以一定的增量进行排序。然后会继续以一定增量进行排序，最终算法以增量为1进行排序。当增量为1时，算法变为插入排序，这就保证了数据一定会被排序。 ## 算法原理：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量`d2&lt;d1`重复上述的分组和排序，直至所取的增量`dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)`，即所有记录放在同一组中进行直接插入排序为止。 增量的选择有很多，并且关乎算法的效率。增量序列的一种流行选择是使用Shell建议的序列，`d1 = [ N / 2]`和`d(t) = [ d(t-1)/2 ]`。 已知的最好步长串行是由Sedgewick提出的 `(1, 5, 19, 41, 109,...)`，该串行的项来自 `9 * 4^i - 9 * 2^i + 1` 和 `4^i - 3 * 2^i + 1` 这两个算式，这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 ## 算法分析：#### 优劣希尔排序是基于插入排序的一种算法，在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^3/2)，但是现今仍然没有人能找出希尔排序的精确下界。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n²)复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。 #### 时间性能1. 增量序列的选择Shell排序的执行时间依赖于增量序列。好的增量序列的共同特征：- 最后一个增量必须为1；- 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。有人通过大量的实验，给出了较好的结果：当n较大时，比较和移动的次数约在nl.25到1.6n1.25之间。 2． Shell排序的时间性能优于直接插入排序希尔排序的时间性能优于直接插入排序的原因：①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。②当n值较小时，n和的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0()差别不大。③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。 因此，希尔排序在效率上较直接插入排序有较大的改进。 ## 算法稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 ## 算法实现：```Ctypedef int ElemType;void Shellsort( ElemType A[], int N )&#123; int i, j, Increment; ElemType Tmp; for( Increment = N / 2; Increment &gt; 0; Increment /= 2 ) for( i = Increment; i &lt; N; i++ ) &#123; Tmp = A[ i ]; for( j = i; j &gt;= Increment; j -= Increment ) if( Tmp &lt; A[ j - Increment ] ) A[ j ] = A[ j - Increment]; else break; A[ j ] = Tmp; &#125;&#125; 选择排序(Selection sort)选择排序(Selection sort)是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法原理： 从未排序的数组中选择最小的元素，组成有序序列。 从无序序列中继续挑选最小的元素，插入有序序列。 以此类推，直到全部转化为有序序列。 算法分析：选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。 比较次数O(n^2),比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+...+1=n*(n-1)/2。 交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。 算法稳定性：选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 算法实现：1234567891011121314151617181920212223typedef int ElemType;void Selectsort( ElemType A[], int N )&#123; int i, j, loc; ElemType min, Tmp; for( i = 0; i &lt; N; i++) &#123; min = A[ i ]; for( j = i; j &lt; N; j++) &#123; if( A[ j ] &lt;= min ) &#123; min = A[ j ]; loc = j; &#125; &#125; Tmp = A[ i ]; A[ i ] = A[ loc ]; A[ loc ] = Tmp; &#125;&#125; 堆排序(Heapsort)堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆节点的访问通常堆是通过一维数组来实现的。在起始数组为 0 的情形中： 父节点i的左子节点在位置 (2*i+1); 父节点i的右子节点在位置 (2*i+2); 子节点i的父节点在位置 floor((i-1)/2); 堆的操作在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 算法原理： 先将无序的数组建立成一个最大堆(即最大值位于根结点的完全二叉树)。 依次从最大堆中删除最大值，放入数组尾部，并将最大堆重新调整。直到全部删除为止。 算法分析：堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用PercDown(下滤算法)实现的。 平均性能 O(N*logN)。 其他性能 由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。 堆排序是就地排序，辅助空间为O(1）. 在最坏的情况下，堆排序最多使用2NlogN - O(N)次比较。 算法稳定性：它是不稳定的排序方法。 算法实现：123456789101112131415161718192021222324252627282930313233343536#define LeftChild(i) (2*(i)+1)typedef int ElemType;void PercDown( ElemType A[], int i, int N )&#123; int Child; ElemType Tmp; for( Tmp = A[ i ]; LeftChild( i ) &lt; N; i = Child ) &#123; Child = LeftChild( i ); if( Child != N - 1 &amp;&amp; A[ Child + 1 ] &gt; A[ Child ]) Child++; if( Tmp &lt; A[ Child ]) A[ i ] = A[ Child ]; else break; &#125; A[ i ] = Tmp;&#125;void Heapsort( ElemType A[], int N )&#123; int i; ElemType Tmp; for( i = N / 2; i &gt;= 0; i-- ) PercDown( A, i, N); for( i = N - 1; i &gt; 0; i-- ) &#123; Tmp = A[ 0 ]; A[ 0 ] = A[ i ]; A[ i ] = Tmp; PercDown( A, 0, i ); &#125;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post Test]]></title>
    <url>%2F2014%2FHexo%2Fpost-test%2F</url>
    <content type="text"><![CDATA[视频&amp;音频测试 唉？插首歌听听看？ 再来个视频！]]></content>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2014%2FHexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是一个用hexo搭建的博客。 hexo是基于Node.js的一个博客框架，由台湾的大学生tommy351所写……（人家都能写出框架了我还什么都不会&gt;_&lt;）。 我在寒假之前就有了搭一个博客的想法，当时比较热血，想不用现成的框架从后台撸到前端一个人通通搞定。所以整个寒假都在宅在家，看了Python学了点Django，又了解了一点前端的知识。这么多东西看下来虽然不是很费劲，但是真正要开始动手做的时候才发现，继续学习的周期和搭建的时间实在太长，为了一个博客实在不值得，如果真要学这些知识，以后可以慢慢来，有针对性地去做，而不是妄图一口吃成个胖子，在什么都不懂的时候干一个Full Stack developer才能做的事。 吾生也有涯，而知也无涯。以有涯随无涯，殆已。 知乎上有个题主说的很对：“不要试图使自己做个万能的人，去关注你最为关注的东西。” 虽然这个博客不是用Django搭建，但寒假的学习也让我了解了很多LAMP和web方面的东西，并没有白白浪费时间。 当然了这些都不是重点，我搭这个博客也不是为了好玩打发时间，而是想把自己学习的东西记录下来，分享出去，也算是对自己的生活有个记录和交代。这个其实也是向林文学长和张春荣学长学习的，我曾经从他们身上学到和了解到了很多东西，他们也在继续影响着我，如果不是因为他们，我现在可能更渣。 虽然已经大二了，但有些东西现在开始，也为时未晚罢。 就是这样。 choice = int(raw_input(&quot;&quot;&quot;If u like this blog, enter 1, else whatever.\n&quot;&quot;&quot;)) while choice != 1: choice = int(raw_input(&apos;Please?&gt;_&lt;\n&apos;)) else: print &apos;I like u!&apos;]]></content>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
</search>